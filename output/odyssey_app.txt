Path: /lib/features/category/data/datasources/local_categories_datasource.dart

import 'dart:convert';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:twins/core/domain/entities/either.dart';
import 'package:twins/core/exceptions/app_exceptions.dart';
import 'package:twins/features/category/domain/entities/category_entity.dart';
String _key = "category";
class LocalCategoriesDataSource {
  final SharedPreferences? sharedPreferences;
  LocalCategoriesDataSource({required this.sharedPreferences});
  Future<Either<AppException, CategoryEntity?>> fetchSavedCategory() async {
    try {
      final valueString = sharedPreferences?.getString(_key);
      if (valueString != null) {
        final json = jsonDecode(valueString);
        return Either.right(CategoryEntity.fromJson(json));
      } else {
        return Either.right(null);
      }
    } catch (e) {
      return Either.left(
        AppException(
          message: 'Error fetching saved category: $e',
          statusCode: 500,
          identifier: 'Unknown error',
        ),
      );
    }
  }
  Future<Either<AppException, CategoryEntity>> updateSavedCategory(
      CategoryEntity newCategory) async {
    try {
      await sharedPreferences?.setString(_key, jsonEncode(newCategory.toJson()));
      return Either.right(newCategory);
    } catch (e) {
      return Either.left(
        AppException(
          message: 'Error fetching saved category: $e',
          statusCode: 500,
          identifier: 'Unknown error',
        ),
      );
    }
  }
}
---
Path: /lib/features/category/data/datasources/remote_categories_datasource.dart

import 'package:dio/dio.dart';
import 'package:twins/core/domain/entities/either.dart';
import 'package:twins/core/exceptions/app_exceptions.dart';
import 'package:twins/features/category/domain/entities/category_entity.dart';
import 'package:twins/models/api/module_request.dart';
class RemoteCategoriesDataSource {
  final Dio dio;
  RemoteCategoriesDataSource({required this.dio});
  Future<Either<AppException, List<CategoryEntity>>> fetchCategories() async {
    try {
      String path = '/categories/';
      Response response = await dio.get(path);
      List jsonList = response.data;
      final categories = jsonList.map((e) => CategoryEntity.fromJson(e)).toList();
      return Either.right(categories);
    } catch (e) {
      return Either.left(
        AppException(
          message: "Error fetching categories: $e",
          statusCode: 500,
          identifier: 'Unknown error',
        ),
      );
    }
  }
  Future<Either<AppException, List<GeniusModule>>> fetchCategoryModules(String categoryId) async {
    try {
      String path = '/categories/$categoryId/modules';
      Response response = await dio.get(path);
      List jsonList = response.data;
      final modules = jsonList.map((e) => GeniusModule.fromJson(e)).toList();
      return Either.right(modules);
    } catch (e) {
      return Either.left(
        AppException(
          message: "Error fetching category $categoryId modules: $e",
          statusCode: 500,
          identifier: 'Unknown error',
        ),
      );
    }
  }
}
---
Path: /lib/features/category/data/repositories/category_repository_impl.dart

import 'package:twins/core/domain/entities/either.dart';
import 'package:twins/core/exceptions/app_exceptions.dart';
import 'package:twins/features/category/data/datasources/local_categories_datasource.dart';
import 'package:twins/features/category/data/datasources/remote_categories_datasource.dart';
import 'package:twins/features/category/domain/entities/category_entity.dart';
import 'package:twins/features/category/domain/repositories/category_repository.dart';
import 'package:twins/models/api/module_request.dart';
class CategoryRepositoryImpl implements CategoryRepository {
  final RemoteCategoriesDataSource _remoteCategoriesDataSource;
  final LocalCategoriesDataSource _localCategoriesDataSource;
  CategoryRepositoryImpl(this._remoteCategoriesDataSource, this._localCategoriesDataSource);
  @override
  Future<Either<AppException, List<CategoryEntity>>> fetchCategories() async =>
      await _remoteCategoriesDataSource.fetchCategories();
  @override
  Future<Either<AppException, List<GeniusModule>>> fetchCategoryModules(String categoryId) async =>
      await _remoteCategoriesDataSource.fetchCategoryModules(categoryId);
  @override
  Future<Either<AppException, CategoryEntity?>> fetchSavedCategory() async =>
      await _localCategoriesDataSource.fetchSavedCategory();
  @override
  Future<Either<AppException, CategoryEntity>> updateSavedCategory(
          CategoryEntity newCategory) async =>
      await _localCategoriesDataSource.updateSavedCategory(newCategory);
}
---
Path: /lib/features/category/domain/entities/category_entity.dart

import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:twins/models/api/module_request.dart';
part 'category_entity.freezed.dart';
part 'category_entity.g.dart';
@freezed
class CategoryEntity with _$CategoryEntity {
  const CategoryEntity._();
  const factory CategoryEntity({
    required String id,
    required String name,
  }) = _CategoryEntity;
  factory CategoryEntity.fromJson(Map<String, Object?> json) => _$CategoryEntityFromJson(json);
}
@freezed
class CategoriesState with _$CategoriesState {
  const CategoriesState._();
  const factory CategoriesState.loading() = CategoriesStateLoading;
  const factory CategoriesState.success(List<CategoryEntity> categories) = CategoriesStateSuccess;
  const factory CategoriesState.error(String message) = CategoriesStateError;
}
@freezed
class CategoryModulesState with _$CategoryModulesState {
  const CategoryModulesState._();
  const factory CategoryModulesState.loading() = CategoryModulesStateLoading;
  const factory CategoryModulesState.success(List<GeniusModule> modules) =
      CategoryModulesStateSuccess;
  const factory CategoryModulesState.error(String message) = CategoryModulesStateError;
}
---
Path: /lib/features/category/domain/repositories/category_repository.dart

import 'package:twins/core/domain/entities/either.dart';
import 'package:twins/core/exceptions/app_exceptions.dart';
import 'package:twins/features/category/domain/entities/category_entity.dart';
import 'package:twins/models/api/module_request.dart';
abstract class CategoryRepository {
  Future<Either<AppException, List<CategoryEntity>>> fetchCategories();
  Future<Either<AppException, List<GeniusModule>>> fetchCategoryModules(String categoryId);
  Future<Either<AppException, CategoryEntity?>> fetchSavedCategory();
  Future<Either<AppException, CategoryEntity>> updateSavedCategory(CategoryEntity newCategory);
}
---
Path: /lib/features/category/domain/usecases/fetch_categories_use_case.dart

import 'package:twins/core/domain/entities/either.dart';
import 'package:twins/core/exceptions/app_exceptions.dart';
import 'package:twins/features/category/domain/entities/category_entity.dart';
import 'package:twins/features/category/domain/repositories/category_repository.dart';
class FetchCategories {
  final CategoryRepository _repository;
  FetchCategories(this._repository);
  Future<Either<AppException, List<CategoryEntity>>> call() async =>
      await _repository.fetchCategories();
}
---
Path: /lib/features/category/domain/usecases/fetch_category_modules_use_case.dart

import 'package:twins/core/domain/entities/either.dart';
import 'package:twins/core/exceptions/app_exceptions.dart';
import 'package:twins/features/category/domain/repositories/category_repository.dart';
import 'package:twins/models/api/module_request.dart';
class FetchCategoryModules {
  final CategoryRepository _repository;
  FetchCategoryModules(this._repository);
  Future<Either<AppException, List<GeniusModule>>> call(String categoryId) {
    return _repository.fetchCategoryModules(categoryId);
  }
}
---
Path: /lib/features/category/domain/usecases/fetch_saved_category_use_case.dart

import 'package:twins/core/domain/entities/either.dart';
import 'package:twins/core/exceptions/app_exceptions.dart';
import 'package:twins/features/category/domain/entities/category_entity.dart';
import 'package:twins/features/category/domain/repositories/category_repository.dart';
class FetchSavedCategory {
  final CategoryRepository _repository;
  FetchSavedCategory(this._repository);
  Future<Either<AppException, CategoryEntity?>> call() async =>
      await _repository.fetchSavedCategory();
}
---
Path: /lib/features/category/domain/usecases/update_saved_category_use_case.dart

import 'package:twins/core/domain/entities/either.dart';
import 'package:twins/core/exceptions/app_exceptions.dart';
import 'package:twins/features/category/domain/entities/category_entity.dart';
import 'package:twins/features/category/domain/repositories/category_repository.dart';
class UpdateSavedCategory {
  final CategoryRepository _repository;
  UpdateSavedCategory(this._repository);
  Future<Either<AppException, CategoryEntity>> call(CategoryEntity newCategory) async =>
      await _repository.updateSavedCategory(newCategory);
}
---
Path: /lib/features/category/presentation/riverpod/category_provider.dart

import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:twins/features/category/data/datasources/local_categories_datasource.dart';
import 'package:twins/features/category/data/datasources/remote_categories_datasource.dart';
import 'package:twins/features/category/data/repositories/category_repository_impl.dart';
import 'package:twins/features/category/domain/entities/category_entity.dart';
import 'package:twins/features/category/domain/repositories/category_repository.dart';
import 'package:twins/features/category/domain/usecases/fetch_categories_use_case.dart';
import 'package:twins/features/category/domain/usecases/fetch_category_modules_use_case.dart';
import 'package:twins/features/category/domain/usecases/fetch_saved_category_use_case.dart';
import 'package:twins/features/category/domain/usecases/update_saved_category_use_case.dart';
import 'package:twins/providers/dio_client_provider.dart';
import 'package:twins/providers/shared_preferences_provider.dart';
part 'category_provider.g.dart';
@riverpod
RemoteCategoriesDataSource remoteCategoriesDataSource(RemoteCategoriesDataSourceRef ref) {
  final dio = ref.watch(dioClientProvider);
  return RemoteCategoriesDataSource(dio: dio);
}
@riverpod
LocalCategoriesDataSource localCategoriesDataSource(LocalCategoriesDataSourceRef ref) {
  final sharedPreference = ref.watch(sharedPreferencesOrNullProvider);
  return LocalCategoriesDataSource(sharedPreferences: sharedPreference);
}
@riverpod
CategoryRepository categoryRepository(CategoryRepositoryRef ref) {
  final remoteDataSource = ref.watch(remoteCategoriesDataSourceProvider);
  final localDataSource = ref.watch(localCategoriesDataSourceProvider);
  return CategoryRepositoryImpl(remoteDataSource, localDataSource);
}
@riverpod
FetchCategories fetchCategories(FetchCategoriesRef ref) {
  final repository = ref.watch(categoryRepositoryProvider);
  return FetchCategories(repository);
}
@riverpod
FetchCategoryModules fetchCategoryModules(FetchCategoryModulesRef ref) {
  final repository = ref.watch(categoryRepositoryProvider);
  return FetchCategoryModules(repository);
}
@riverpod
FetchSavedCategory fetchSavedCategory(FetchSavedCategoryRef ref) {
  final repository = ref.watch(categoryRepositoryProvider);
  return FetchSavedCategory(repository);
}
@riverpod
UpdateSavedCategory updateSavedCategory(UpdateSavedCategoryRef ref) {
  final repository = ref.watch(categoryRepositoryProvider);
  return UpdateSavedCategory(repository);
}
@riverpod
class CategoriesNotifier extends _$CategoriesNotifier {
  late FetchCategories _fetchCategories;
  late FetchSavedCategory _fetchSavedCategory;
  late UpdateSavedCategory _updateSavedCategory;
  late CategoryEntity _selectedCategory;
  @override
  CategoriesState build() {
    _fetchCategories = ref.watch(fetchCategoriesProvider);
    _fetchSavedCategory = ref.watch(fetchSavedCategoryProvider);
    _updateSavedCategory = ref.watch(updateSavedCategoryProvider);
    loadCategories();
    return const CategoriesState.loading();
  }
  Future<void> loadCategories() async {
    state = const CategoriesState.loading();
    final resultCategories = await _fetchCategories();
    resultCategories.fold(
      (error) => state = CategoriesState.error(error.message),
      (categories) => state = CategoriesState.success(categories),
    );
    await _loadSavedCategory();
  }
  Future<void> _loadSavedCategory() async {
    final resultSavedCategory = await _fetchSavedCategory();
    resultSavedCategory.fold(
      (p0) => null,
      (category) {
        if (category != null) {
          _selectedCategory = category;
        } else {
          CategoriesState categoriesState = state;
          if (categoriesState is CategoriesStateSuccess) {
            if (categoriesState.categories.isNotEmpty) {
              _selectedCategory = categoriesState.categories.first;
              _updateSavedCategory(_selectedCategory);
            }
          }
        }
      },
    );
    final categoryModulesNotifier = ref.read(categoryModulesNotifierProvider.notifier);
    categoryModulesNotifier.loadCategoryModules(_selectedCategory.id);
  }
  void selectCategory(CategoryEntity newCategory) {
    CategoriesState categoriesState = state;
    if (categoriesState is CategoriesStateSuccess) {
      final categories = categoriesState.categories;
      _selectedCategory = newCategory;
      state = CategoriesState.success(categories);
      _updateSavedCategory(_selectedCategory);
      final categoryModulesNotifier = ref.read(categoryModulesNotifierProvider.notifier);
      categoryModulesNotifier.loadCategoryModules(_selectedCategory.id);
    }
  }
  bool isSelected(CategoryEntity newCategory) => newCategory.id == _selectedCategory.id;
}
@riverpod
bool categoriesIsLoading(CategoriesIsLoadingRef ref) {
  return ref.watch(categoriesNotifierProvider).maybeWhen(
        loading: () => true,
        success: (categories) => false,
        orElse: () => false,
      );
}
@riverpod
class CategoryModulesNotifier extends _$CategoryModulesNotifier {
  late FetchCategoryModules _fetchCategoryModules;
  @override
  CategoryModulesState build() {
    _fetchCategoryModules = ref.watch(fetchCategoryModulesProvider);
    return const CategoryModulesState.loading();
  }
  Future<void> loadCategoryModules(String categoryId) async {
    state = const CategoryModulesState.loading();
    final result = await _fetchCategoryModules(categoryId);
    result.fold(
      (error) => state = CategoryModulesState.error(error.message),
      (modules) => state = CategoryModulesState.success(modules),
    );
  }
}
---
Path: /lib/features/category/presentation/widgets/categories_list_view.dart

import 'package:flutter/material.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:twins/features/category/domain/entities/category_entity.dart';
import 'package:twins/features/category/presentation/riverpod/category_provider.dart';
import 'package:twins/features/category/presentation/widgets/category_card.dart';
class CategoriesListView extends ConsumerWidget {
  final List<CategoryEntity> items;
  const CategoriesListView({super.key, required this.items});
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return ListView(
      scrollDirection: Axis.horizontal,
      children: [
        for (final item in items)
          CategoryCard(
            category: item,
            isSelected: ref.watch(categoriesNotifierProvider.notifier).isSelected(item),
            onTap: (p0) => ref.read(categoriesNotifierProvider.notifier).selectCategory(p0),
          )
      ],
    );
  }
}
---
Path: /lib/features/category/presentation/widgets/category_card.dart

import 'package:flutter/material.dart';
import 'package:twins/features/category/domain/entities/category_entity.dart';
import 'package:twins/style/values.dart';
class CategoryCard extends StatelessWidget {
  final CategoryEntity category;
  final bool isSelected;
  final Function(CategoryEntity) onTap;
  const CategoryCard({
    Key? key,
    required this.category,
    required this.isSelected,
    required this.onTap,
  }) : super(key: key);
  @override
  Widget build(BuildContext context) {
    final containerDecoration = BoxDecoration(
      border: Border.all(color: C.GENIUS_GREY_DARK),
      color: isSelected ? C.GENIUS_PRIMARY : C.GENIUS_WHITE,
      borderRadius: BorderRadius.circular(20),
    );
    final textStyle = TextStyle(
      color: isSelected ? C.GENIUS_WHITE : C.GENIUS_BLACK,
    );
    return Padding(
      padding: const EdgeInsets.only(right: 16.0),
      child: InkWell(
        onTap: () => onTap(category),
        child: Container(
          decoration: containerDecoration,
          padding: const EdgeInsets.symmetric(
            horizontal: 16.0,
            vertical: 8.0,
          ),
          child: Text(
            category.name,
            style: textStyle,
          ),
        ),
      ),
    );
  }
}
---
Path: /lib/features/category/presentation/widgets/category_modules_section.dart

import 'package:auto_size_text/auto_size_text.dart';
import 'package:flutter/material.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:twins/features/category/presentation/riverpod/category_provider.dart';
import 'package:twins/models/api/module_request.dart';
import 'package:twins/pages/learn_pages/module_page.dart';
import 'package:twins/pages/learn_pages/widgets/module_card.dart';
class CategoryModulesSection extends HookConsumerWidget {
  const CategoryModulesSection({super.key});
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final categoryModulesNotifier = ref.watch(categoryModulesNotifierProvider);
    List<Widget> generatePlaceholders({int n = 3}) {
      return [
        for (var i = 0; i < n; i++) ...[
          const ModuleCard(
            module: GeniusModule(
                id: '',
                key: '',
                title: '',
                description: '',
                image: null,
                level: '',
                isPro: false,
                lessons: []),
            isPlaceholder: true,
          ),
        ]
      ];
    }
    return GridView.count(
      shrinkWrap: true,
      primary: false,
      physics: const NeverScrollableScrollPhysics(),
      crossAxisCount: 3,
      mainAxisSpacing: 20,
      crossAxisSpacing: 20,
      childAspectRatio: 3 / 4,
      padding: const EdgeInsets.symmetric(vertical: 10, horizontal: 5),
      children: [
        ...categoryModulesNotifier.maybeMap(
          orElse: () => [],
          success: (data) {
            return [
              ...data.modules
                  .expand(
                    (module) => [
                      Consumer(
                        builder: (context, ref, child) {
                          return InkWell(
                            onTap: () async {
                              await ModulePage(
                                module: module,
                              ).show();
                            },
                            child: ModuleCard(module: module),
                          );
                        },
                      ),
                    ],
                  )
                  .toList(),
            ];
          },
          error: (err) => [
            SizedBox(
              height: 150,
              width: double.infinity,
              child: Padding(
                padding: const EdgeInsets.all(8.0),
                child: Column(
                  children: [
                    Icon(
                      Icons.public_off_rounded,
                      size: 40,
                      color: Colors.grey.shade400,
                    ),
                    const SizedBox(height: 10),
                    const AutoSizeText(
                      'Something went wrong. Please retry later.',
                      textAlign: TextAlign.center,
                    ),
                    AutoSizeText(err.message.toString()),
                  ],
                ),
              ),
            ),
          ],
          loading: (d) => generatePlaceholders(),
        ),
      ],
    );
  }
}
---
Path: /lib/features/category/presentation/widgets/category_section.dart

import 'package:flutter/material.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:twins/features/category/presentation/riverpod/category_provider.dart';
import 'categories_list_view.dart';
class CategorySection extends HookConsumerWidget {
  const CategorySection({super.key});
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final categoriesNotifier = ref.watch(categoriesNotifierProvider);
    return categoriesNotifier.maybeWhen(
      orElse: () => const SizedBox.shrink(),
      success: (categories) => SizedBox(
        height: 40,
        width: double.infinity,
        child: CategoriesListView(items: categories),
      ),
    );
  }
}
---
Path: /lib/models/mcq_exercise_model.dart

import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:twins/models/api/lesson_request.dart';
part 'mcq_exercise_model.freezed.dart';
@freezed
class MCQExerciseData with _$MCQExerciseData {
  const MCQExerciseData._();
  const factory MCQExerciseData(
    TranslatedConcept answer,
    List<TranslatedConcept> concepts,
  ) = _MCQExerciseData;
  factory MCQExerciseData.createMCQExerciseData({
    required TranslatedConcept correctAnswer,
    required List<TranslatedConcept> options,
    bool shuffle = true,
    int nbOptions = 4,
    bool answerIsInOptions = false,
  }) {
    final wrongChoices = List<TranslatedConcept>.from(options);
    if (shuffle) {
      wrongChoices.shuffle();
    }
    int numberOfNonAddedChoices = answerIsInOptions ? 0 : 1;
    List<TranslatedConcept> choices = wrongChoices
      ..length = options.length > nbOptions - numberOfNonAddedChoices
          ? nbOptions - numberOfNonAddedChoices
          : options.length;
    if (!answerIsInOptions) {
      choices.add(correctAnswer);
    }
    if (shuffle) {
      choices.shuffle();
    }
    return MCQExerciseData(correctAnswer, choices);
  }
}
---
Path: /lib/models/notification_panel_model.dart

import 'package:flutter/material.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
part 'notification_panel_model.freezed.dart';
enum NotificationPanelType {
  info,
  success,
  warning,
  error,
}
@freezed
class NotificationPanelData with _$NotificationPanelData {
  const NotificationPanelData._();
  const factory NotificationPanelData({
    required String id,
    required NotificationPanelType notificationType,
    required Widget child,
  }) = _NotificationPanelData;
}
---
Path: /lib/models/setting_model.dart

import 'package:freezed_annotation/freezed_annotation.dart';
part 'setting_model.g.dart';
part 'setting_model.freezed.dart';
@freezed
class Setting with _$Setting {
  const Setting._();
  factory Setting({
    @Default(true) bool globalSoundEnabled,
    @Default(true) bool sfxEnabled,
    @Default(true) bool hapticEnabled,
  }) = _Setting;
  factory Setting.fromJson(Map<String, Object?> json) => _$SettingFromJson(json);
}
---
Path: /lib/models/speech_to_text_model.dart

import 'package:freezed_annotation/freezed_annotation.dart';
part 'speech_to_text_model.freezed.dart';
enum SpeechToTextStatus {
  stopped,
  listening,
  failure,
}
@freezed
class SpeechToTextState with _$SpeechToTextState {
  const SpeechToTextState._();
  const factory SpeechToTextState({
    required bool hasAccess,
    required SpeechToTextStatus status,
    required String? error,
  }) = _SpeechToTextState;
}
---
Path: /lib/models/user_capability.dart

import 'package:freezed_annotation/freezed_annotation.dart';
part 'user_capability.freezed.dart';
@freezed
class UserCapabilityState with _$UserCapabilityState {
  const factory UserCapabilityState.initial() = _Initial;
  const factory UserCapabilityState.limitReached() = _LimitReached;
  const factory UserCapabilityState.can() = _Can;
}
---
Path: /lib/models/user_model.dart

import 'package:freezed_annotation/freezed_annotation.dart';
part 'user_model.freezed.dart';
part 'user_model.g.dart';
@freezed
class UserProfile with _$UserProfile {
  const UserProfile._();
  const factory UserProfile({
    required String? id,
    required String? name,
    required String? level,
    required String? role,
    required String? character,
    required bool registered,
  }) = _UserProfile;
  factory UserProfile.fromJson(Map<String, Object?> json) => _$UserProfileFromJson(json);
  static UserProfile nullify(UserProfile userProfile) {
    return UserProfile(
      id: userProfile.id,
      name: null,
      level: null,
      role: userProfile.role,
      character: null,
      registered: false,
    );
  }
}
@freezed
class UserState with _$UserState {
  const UserState._();
  const factory UserState.loading() = UserStateLoading;
  const factory UserState.success(UserProfile userProfile) = UserStateSuccess;
  const factory UserState.error(String message) = UserStateError;
  bool get completed {
    return map(
        loading: (_) => false,
        error: (_) => false,
        success: (userState) {
          return userState.userProfile.level != null &&
              userState.userProfile.name != null &&
              userState.userProfile.level!.isNotEmpty &&
              userState.userProfile.name!.isNotEmpty &&
              userState.userProfile.character != null &&
              userState.userProfile.character!.isNotEmpty &&
              userState.userProfile.registered;
        });
  }
}
---
Path: /lib/models/exercise_reward.dart

import 'package:freezed_annotation/freezed_annotation.dart';
part 'exercise_reward.freezed.dart';
part 'exercise_reward.g.dart';
@freezed
class ExerciseReward with _$ExerciseReward {
  const ExerciseReward._();
  const factory ExerciseReward({
    required String image,
    required int coins,
    required String sentence,
  }) = _ExerciseReward;
  factory ExerciseReward.fromJson(Map<String, Object?> json) => _$ExerciseRewardFromJson(json);
}
---
Path: /lib/models/api/exercise_request.dart

import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:twins/models/api/lesson_request.dart';
part 'exercise_request.freezed.dart';
part 'exercise_request.g.dart';
@freezed
class VocabularyAcquisitionData with _$VocabularyAcquisitionData {
  const VocabularyAcquisitionData._();
  const factory VocabularyAcquisitionData({
    required TranslatedConcept concept,
  }) = _VocabularyAcquisitionData;
  factory VocabularyAcquisitionData.fromJson(Map<String, Object?> json) =>
      _$VocabularyAcquisitionDataFromJson(json);
}
@freezed
class VocabularyPracticeData with _$VocabularyPracticeData {
  const VocabularyPracticeData._();
  const factory VocabularyPracticeData({
    required TranslatedConcept concept,
    required List<TranslatedConcept> choices,
  }) = _VocabularyPracticeData;
  factory VocabularyPracticeData.fromJson(Map<String, Object?> json) =>
      _$VocabularyPracticeDataFromJson(json);
}
@freezed
class WordReorderingData with _$WordReorderingData {
  const WordReorderingData._();
  const factory WordReorderingData({
    required String sentence,
    required String goodSentence,
    required List<TranslatedConcept> choices,
  }) = _WordReorderingData;
  factory WordReorderingData.fromJson(Map<String, Object?> json) =>
      _$WordReorderingDataFromJson(json);
}
@freezed
class WordCompletionData with _$WordCompletionData {
  const WordCompletionData._();
  const factory WordCompletionData({
    required String sentence,
    required TranslatedConcept concept,
    required List<TranslatedConcept> choices,
  }) = _WordCompletionData;
  factory WordCompletionData.fromJson(Map<String, Object?> json) =>
      _$WordCompletionDataFromJson(json);
}
@freezed
class ReadingData with _$ReadingData {
  const ReadingData._();
  const factory ReadingData({
    required String text,
    required TranslatedConcept concept,
    required List<TranslatedConcept> choices,
  }) = _ReadingData;
  factory ReadingData.fromJson(Map<String, Object?> json) => _$ReadingDataFromJson(json);
}
@freezed
class ListeningData with _$ListeningData {
  const ListeningData._();
  const factory ListeningData({
    required String audio,
    required String? image,
    required bool? displayWords,
    required TranslatedConcept concept,
    required List<TranslatedConcept> choices,
  }) = _ListeningData;
  factory ListeningData.fromJson(Map<String, Object?> json) => _$ListeningDataFromJson(json);
}
enum ChatExchangeDataDisplayType {
  USER_LANGUAGE,
  LEARNING_LANGUAGE,
}
enum ChatExchangeDataType {
  ASSISTANT,
  USER,
  INPUT,
}
@freezed
class ChatExchangeData with _$ChatExchangeData {
  const ChatExchangeData._();
  const factory ChatExchangeData({
    required String id,
    required ChatExchangeDataType type,
    required String? emotion,
    required TranslatedConcept concept,
    required List<TranslatedConcept> choices,
  }) = _ChatExchangeData;
  factory ChatExchangeData.fromJson(Map<String, Object?> json) => _$ChatExchangeDataFromJson(json);
}
@freezed
class ScriptedConversationData with _$ScriptedConversationData {
  const ScriptedConversationData._();
  const factory ScriptedConversationData({
    required List<ChatExchangeData> conversation,
  }) = _ScriptedConversationData;
  factory ScriptedConversationData.fromJson(Map<String, Object?> json) =>
      _$ScriptedConversationDataFromJson(json);
}
@freezed
class ExplanationData with _$ExplanationData {
  const ExplanationData._();
  const factory ExplanationData({
    required List<TranslatedConcept> texts,
  }) = _ExplanationData;
  factory ExplanationData.fromJson(Map<String, Object?> json) => _$ExplanationDataFromJson(json);
}
@Freezed(
    unionKey: 'type', fallbackUnion: 'unknown', unionValueCase: FreezedUnionCase.screamingSnake)
class ExerciseData with _$ExerciseData {
  const ExerciseData._();
  const factory ExerciseData.vocabularyAcquisition(
      VocabularyAcquisitionData vocabularyAcquisition) = VocabularyAcquisition;
  const factory ExerciseData.vocabularyPractice(VocabularyPracticeData vocabularyPractice) =
      VocabularyPractice;
  const factory ExerciseData.wordReordering(WordReorderingData wordReordering) = WordReordering;
  const factory ExerciseData.wordCompletion(WordCompletionData wordCompletion) = WordCompletion;
  const factory ExerciseData.reading(ReadingData reading) = Reading;
  const factory ExerciseData.listening(ListeningData listening) = Listening;
  const factory ExerciseData.scriptedConversation(ScriptedConversationData scriptedConversation) =
      ScriptedConversation;
  const factory ExerciseData.explanation(ExplanationData explanation) = Explanation;
  const factory ExerciseData.unknown({
    required String type,
  }) = Unknown;
  factory ExerciseData.fromJson(Map<String, Object?> json) => _$ExerciseDataFromJson(json);
  int get exerciseCount {
    return map(
      vocabularyAcquisition: (_) => 1,
      vocabularyPractice: (_) => 1,
      wordReordering: (_) => 1,
      wordCompletion: (_) => 1,
      reading: (_) => 1,
      listening: (_) => 1,
      scriptedConversation: (data) => data.scriptedConversation.conversation
          .where((element) => element.type == ChatExchangeDataType.INPUT)
          .length,
      explanation: (_) => 0,
      unknown: (_) => 1,
    );
  }
  List<String> get neededFiles {
    return map(
      vocabularyAcquisition: (ex) => ex.vocabularyAcquisition.concept.image == null
          ? []
          : [ex.vocabularyAcquisition.concept.image!],
      vocabularyPractice: (ex) =>
          ex.vocabularyPractice.concept.image == null ? [] : [ex.vocabularyPractice.concept.image!],
      wordReordering: (_) => [],
      wordCompletion: (_) => [],
      reading: (_) => [],
      listening: (ex) => ex.listening.image == null ? [] : [ex.listening.image!],
      scriptedConversation: (_) => [],
      explanation: (_) => [],
      unknown: (_) => [],
    );
  }
  bool get fullScreen {
    return map(
      vocabularyAcquisition: (_) => false,
      vocabularyPractice: (_) => false,
      wordReordering: (_) => false,
      wordCompletion: (_) => false,
      reading: (_) => false,
      listening: (_) => false,
      scriptedConversation: (_) => false,
      explanation: (_) => true,
      unknown: (_) => false,
    );
  }
}
---
Path: /lib/models/api/lesson_request.dart

import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:twins/models/api/section_request.dart';
part 'lesson_request.freezed.dart';
part 'lesson_request.g.dart';
@freezed
class Concept with _$Concept {
  const Concept._();
  const factory Concept({
    required String id,
    required String content,
    required String type,
  }) = _Concept;
  factory Concept.fromJson(Map<String, Object?> json) => _$ConceptFromJson(json);
}
@freezed
class TranslatedConcept with _$TranslatedConcept {
  const TranslatedConcept._();
  const factory TranslatedConcept({
    @Default('') String id,
    required String content,
    String? translation,
    String? image,
    @Default('Vocabulary') String type,
  }) = _TranslatedConcept;
  factory TranslatedConcept.fromJson(Map<String, Object?> json) =>
      _$TranslatedConceptFromJson(json);
}
@freezed
class LessonData with _$LessonData {
  const LessonData._();
  const factory LessonData({
    required String id,
    required String key,
    required String title,
    required String description,
    required String? image,
    required List<SectionData> sections,
  }) = _LessonData;
  factory LessonData.fromJson(Map<String, Object?> json) => _$LessonDataFromJson(json);
}
@freezed
class LessonsRequestState with _$LessonsRequestState {
  const LessonsRequestState._();
  const factory LessonsRequestState.initial() = _Initial;
  const factory LessonsRequestState.loading() = _Loading;
  const factory LessonsRequestState.success(List<LessonData> lessons) = _Success;
  const factory LessonsRequestState.failure(String message) = _Failure;
}
@freezed
class LessonsMessageCountState with _$LessonsMessageCountState {
  const LessonsMessageCountState._();
  const factory LessonsMessageCountState({
    required Map<String, int>? map,
  }) = _LessonsMessageCountState;
  factory LessonsMessageCountState.fromJson(Map<String, Object?> json) =>
      _$LessonsMessageCountStateFromJson(json);
  int getLessonMessageCountByKey(String key) {
    if (map == null) return 0;
    return map![key] ?? 0;
  }
}
---
Path: /lib/models/api/module_request.dart

import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:twins/models/api/lesson_request.dart';
part 'module_request.freezed.dart';
part 'module_request.g.dart';
@freezed
class GeniusModule with _$GeniusModule {
  const GeniusModule._();
  const factory GeniusModule({
    required String id,
    required String key,
    required String title,
    required String description,
    required String? image,
    required String level,
    required bool isPro,
    bool? isStarted,
    required List<LessonData> lessons,
  }) = _GeniusModule;
  factory GeniusModule.fromJson(Map<String, Object?> json) => _$GeniusModuleFromJson(json);
}
@freezed
class ModulesState with _$ModulesState {
  const ModulesState._();
  const factory ModulesState.initial() = Initial;
  const factory ModulesState.loading() = Loading;
  const factory ModulesState.success(List<GeniusModule> modules) = Success;
  const factory ModulesState.failure(String message) = Failure;
}
---
Path: /lib/models/api/practice_request.dart

---
Path: /lib/models/api/chat_request.dart

import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:twins/models/api/lesson_request.dart';
part 'chat_request.freezed.dart';
part 'chat_request.g.dart';
enum ChatMessageType {
  message,
  error,
  exerciseError,
}
enum ChatSenderType {
  user,
  assistant,
}
@freezed
class ChatExchange with _$ChatExchange {
  const ChatExchange._();
  const factory ChatExchange({
    required ChatSenderType role,
    required TranslatedConcept concept,
    required ChatMessageType type,
    @Default(false) bool displayTranslation,
  }) = _ChatExchange;
  factory ChatExchange.fromJson(Map<String, Object?> json) => _$ChatExchangeFromJson(json);
  String get Display {
    if (displayTranslation) {
      return concept.translation ?? concept.content;
    }
    return concept.content;
  }
}
@freezed
class ChatResponse with _$ChatResponse {
  const ChatResponse._();
  const factory ChatResponse({
    required List<ChatExchange> replies,
    required String emotion,
  }) = _ChatResponse;
  factory ChatResponse.fromJson(Map<String, Object?> json) => _$ChatResponseFromJson(json);
}
@freezed
class ChatRequestData with _$ChatRequestData {
  const ChatRequestData._();
  const factory ChatRequestData({
    required String characterInfoId,
    required List<ChatExchange> dialogue,
  }) = _ChatRequestData;
  factory ChatRequestData.fromJson(Map<String, Object?> json) => _$ChatRequestDataFromJson(json);
}
@freezed
class ChatRequestState with _$ChatRequestState {
  const ChatRequestState._();
  const factory ChatRequestState.initial() = _Initial;
  const factory ChatRequestState.loading() = _Loading;
  const factory ChatRequestState.success(ChatResponse chat) = _Success;
  const factory ChatRequestState.failure(String message) = _Failure;
}
---
Path: /lib/models/api/section_request.dart

import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:twins/models/api/exercise_request.dart';
part 'section_request.freezed.dart';
part 'section_request.g.dart';
enum SectionType { VOCABULARY, LISTENING, SCRIPTED_CONVERSATION, GRAMMAR }
@freezed
class SectionData with _$SectionData {
  const SectionData._();
  const factory SectionData({
    required String id,
    required SectionType type,
    required String? background,
    required String? character,
    required int? minutes,
    required List<ExerciseData> exercises,
  }) = _SectionData;
  factory SectionData.fromJson(Map<String, Object?> json) => _$SectionDataFromJson(json);
  int get totalExercisesCount =>
      exercises.fold(0, (previousValue, exercise) => previousValue + exercise.exerciseCount);
  List<String> get neededFiles {
    final files = <String>[];
    if (background != null) {
      files.add(background!);
    }
    for (final exercise in exercises) {
      files.addAll(exercise.neededFiles);
    }
    return files;
  }
}
---
Path: /lib/models/results/genius_result.dart

import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:twins/models/results/level_result.dart';
part 'genius_result.freezed.dart';
part 'genius_result.g.dart';
@freezed
class GeniusResult with _$GeniusResult {
  const GeniusResult._();
  const factory GeniusResult({
    required Map<String, LevelResult> levels,
  }) = _GeniusResult;
  factory GeniusResult.fromJson(Map<String, Object?> json) => _$GeniusResultFromJson(json);
}
---
Path: /lib/models/results/lesson_result.dart

import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:twins/models/results/section_result.dart';
part 'lesson_result.freezed.dart';
part 'lesson_result.g.dart';
@freezed
class LessonResult with _$LessonResult {
  const LessonResult._();
  const factory LessonResult({
    required double? score,
    required Map<String, SectionResult> sections,
  }) = _LessonResult;
  factory LessonResult.fromJson(Map<String, Object?> json) => _$LessonResultFromJson(json);
}
---
Path: /lib/models/results/level_result.dart

import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:twins/models/results/module_result.dart';
part 'level_result.freezed.dart';
part 'level_result.g.dart';
@freezed
class LevelResult with _$LevelResult {
  const LevelResult._();
  const factory LevelResult({
    required double? score,
    required Map<String, ModuleResult> modules,
  }) = _LevelResult;
  factory LevelResult.fromJson(Map<String, Object?> json) => _$LevelResultFromJson(json);
}
---
Path: /lib/models/results/module_result.dart

import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:twins/models/results/lesson_result.dart';
part 'module_result.freezed.dart';
part 'module_result.g.dart';
@freezed
class ModuleResult with _$ModuleResult {
  const ModuleResult._();
  const factory ModuleResult({
    required double? score,
    required Map<String, LessonResult> lessons,
  }) = _ModuleResult;
  factory ModuleResult.fromJson(Map<String, Object?> json) => _$ModuleResultFromJson(json);
}
---
Path: /lib/models/results/exercise_result.dart

import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:twins/models/api/lesson_request.dart';
part 'exercise_result.freezed.dart';
part 'exercise_result.g.dart';
@freezed
class ExerciseResult with _$ExerciseResult {
  const ExerciseResult._();
  const factory ExerciseResult({
    required String exerciseId,
    required bool success,
    double? responseTime,
    String? categoryId,
    String? exerciseSessionId,
    required TranslatedConcept? userInput,
    required TranslatedConcept correctAnswer,
  }) = _ExerciseResult;
  factory ExerciseResult.fromJson(Map<String, Object?> json) => _$ExerciseResultFromJson(json);
  Map<String, dynamic> toSubmitJson() {
    return {
      'exerciseId': exerciseId,
      'success': success,
      'responseTime': responseTime,
      'categoryId': categoryId,
      'exerciseSessionId': exerciseSessionId,
    };
  }
}
---
Path: /lib/models/results/section_result.dart

import 'package:freezed_annotation/freezed_annotation.dart';
import 'exercise_result.dart';
part 'section_result.freezed.dart';
part 'section_result.g.dart';
@freezed
class SectionResult with _$SectionResult {
  const SectionResult._();
  const factory SectionResult({
    required double score,
    required List<ExerciseResult> exercises,
  }) = _SectionResult;
  factory SectionResult.fromJson(Map<String, Object?> json) => _$SectionResultFromJson(json);
}
---
Path: /lib/pages/exercises/base_lesson_page.dart

import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:flutter_keyboard_visibility/flutter_keyboard_visibility.dart';
import 'package:gap/gap.dart';
import 'package:twins/style/values.dart';
import 'package:twins/widgets/dialogs/leave_exercise_dialog.dart';
import 'package:twins/widgets/never_avoid_fullscreen_area.dart';
import 'package:twins/widgets/rive/image_or_rive.dart';
import 'package:percent_indicator/linear_percent_indicator.dart';
class BaseLessonPage extends HookWidget {
  final void Function() onLeave;
  final List<Widget> children;
  final double? progress;
  final Widget? topRightContent;
  final String? background;
  final Widget? character;
  final EdgeInsets bodypadding;
  final bool loading;
  final bool exerciseFullScreen;
  const BaseLessonPage({
    required this.onLeave,
    required this.children,
    this.exerciseFullScreen = false,
    this.progress,
    this.topRightContent,
    this.background,
    this.character,
    this.bodypadding = const EdgeInsets.only(left: 20, right: 20),
    required this.loading,
  });
  @override
  Widget build(BuildContext context) {
    final loadingBackgroundState = useState(loading);
    final timedDisplayLoading = loadingBackgroundState.value || loading;
    final displayLoadingState = useState(loading);
    final displayLoading = displayLoadingState.value;
    void handleClose() async {
      if (progress != null && progress! <= 0) {
        onLeave();
        return;
      }
      bool? keepGoing = await LeaveExerciseDialog().show();
      if (keepGoing == false) {
        onLeave();
      }
    }
    useEffect(() {
      if (timedDisplayLoading == false) {
        Future.delayed(const Duration(milliseconds: 1000)).then((value) {
          displayLoadingState.value = false;
        });
      }
      return null;
    }, [timedDisplayLoading]);
    return WillPopScope(
      onWillPop: () async {
        return true;
      },
      child: KeyboardDismissOnTap(
        child: Scaffold(
          body: SizedBox(
            height: double.infinity,
            width: double.infinity,
            child: Stack(
              clipBehavior: Clip.none,
              children: [
                if (exerciseFullScreen == false) ...[
                  if (background != null) ...[
                    NeverAvoidFullscreenArea(
                      child: SizedBox(
                        child: ImageOrRive(
                          background!,
                          onLoaded: () {
                            loadingBackgroundState.value = false;
                          },
                          stateMachine: 'State Machine 1',
                          fit: BoxFit.cover,
                          alignment: Alignment.topCenter,
                        ),
                      ),
                    ),
                  ],
                  if (character != null)
                    Positioned(
                      top: MediaQuery.of(context).size.width / 1280 * 300,
                      left: 0,
                      right: 0,
                      child: Align(
                        child: SizedBox(
                          height: 400,
                          child: character,
                        ),
                      ),
                    ),
                ],
                SafeArea(
                  child: Padding(
                    padding: EdgeInsets.only(top: exerciseFullScreen ? 0 : S.x(4)),
                    child: Stack(
                      fit: StackFit.expand,
                      children: [
                        Padding(
                          padding: bodypadding +
                              EdgeInsets.only(top: exerciseFullScreen ? 0 : S.x(S.x(7))),
                          child: Column(children: children),
                        ),
                        if (exerciseFullScreen == false)
                          Align(
                            alignment: Alignment.topCenter,
                            child: Container(
                              padding: EdgeInsets.symmetric(horizontal: S.x(15)),
                              child: Row(
                                mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  Expanded(
                                    child: Column(
                                      mainAxisSize: MainAxisSize.min,
                                      mainAxisAlignment: MainAxisAlignment.start,
                                      children: [
                                        Gap(S.x(11)),
                                        Row(
                                          children: [
                                            IconButton(
                                              onPressed: handleClose,
                                              icon: const Icon(
                                                Icons.close,
                                                color: Color(0xFFD9D9D9),
                                                size: 40,
                                              ),
                                            ),
                                            if (progress != null)
                                              Expanded(
                                                child: LinearPercentIndicator(
                                                  padding:
                                                      const EdgeInsets.symmetric(horizontal: 60),
                                                  animation: true,
                                                  linearGradient: const LinearGradient(
                                                      colors: [
                                                        Color(0xFF689BFB),
                                                        Color(0xFF68CAF4)
                                                      ],
                                                      begin: Alignment.centerLeft,
                                                      end: Alignment.centerRight),
                                                  lineHeight: 33,
                                                  animationDuration: 300,
                                                  animateFromLastPercent: true,
                                                  percent: progress!,
                                                  barRadius: const Radius.circular(1000),
                                                  backgroundColor:
                                                      const Color.fromARGB(255, 254, 250, 250),
                                                ),
                                              ),
                                          ],
                                        )
                                      ],
                                    ),
                                  ),
                                  if (topRightContent != null) topRightContent!,
                                ],
                              ),
                            ),
                          ),
                      ],
                    ),
                  ),
                ),
                displayLoading
                    ? Positioned.fill(
                        child: Container(
                        color: Colors.white,
                        child: const Center(
                          child: CircularProgressIndicator(),
                        ),
                      ))
                    : Container(),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
---
Path: /lib/pages/exercises/completion_page.dart

import 'package:auto_size_text/auto_size_text.dart';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:twins/features/profile/presentation/providers/profile_provider.dart';
import 'package:twins/mixins/widget.dart';
import 'package:twins/models/exercise_reward.dart';
import 'package:twins/models/results/section_result.dart';
import 'package:twins/providers/genius_result_provider.dart';
import 'package:twins/services/currency_service.dart';
import 'package:twins/services/genius_result_service.dart';
import 'package:twins/services/like_genius_service.dart';
import 'package:twins/style/genius_button_style.dart';
import 'package:twins/style/values.dart';
import 'package:twins/widgets/core/genius_button.dart';
import 'package:twins/widgets/core/tabs.dart';
import 'package:twins/widgets/rive/image_or_rive.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
class CompletionPage extends HookConsumerWidget with PageWidget {
  final SectionResult result;
  final String moduleKey;
  final String lessonKey;
  final String sectionKey;
  CompletionPage({
    required this.result,
    required this.moduleKey,
    required this.lessonKey,
    required this.sectionKey,
  });
  List<ExerciseReward> getExerciseRewards(bool isFirstTime, bool hasNoError, double score) {
    List<ExerciseReward> rewards = [];
    rewards.add(
      ExerciseReward(
        image: 'assets/icons/fire-icon.png',
        coins: isFirstTime ? 10 : 5,
        sentence: isFirstTime ? 'Lesson completed for the first time' : 'Lesson done again',
      ),
    );
    rewards.add(
      ExerciseReward(
        image: 'assets/icons/trophy-icon.png',
        coins: score >= 0.7
            ? 10
            : score >= 0.5
                ? 5
                : 2,
        sentence: score >= 0.7
            ? 'Gold score'
            : score >= 0.5
                ? 'Silver score'
                : 'Bronze score',
      ),
    );
    if (hasNoError) {
      rewards.add(
        const ExerciseReward(
          image: 'assets/icons/rocket-icon.png',
          coins: 5,
          sentence: 'No mistakes',
        ),
      );
    }
    return rewards;
  }
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final userCharacter = ref.watch(userProfileOrNullProvider)?.character;
    final usedCharacter = userCharacter ?? 'assets/rive/character.riv';
    final characterTriggerState = useState('Idle');
    final characterTrigger = characterTriggerState.value;
    final isFirstTime = ref.watch(sectionResultProvider(
          level: 'EIKEN5',
          module: moduleKey,
          lesson: lessonKey,
          section: sectionKey,
        )) ==
        null;
    final hasNoErrors = result.exercises.where((e) => e.success == false).isEmpty;
    final rewards = getExerciseRewards(isFirstTime, hasNoErrors, result.score);
    final coins = rewards.fold<int>(
      0,
      (previousValue, element) => previousValue + element.coins,
    );
    void quit() {
      ref.read(geniusResultServiceProvider.notifier).setPracticeResult(
            level: 'EIKEN5',
            module: moduleKey,
            lesson: lessonKey,
            practice: sectionKey,
            result: result,
          );
    }
    void onDismiss() {
      ref.read(currencyServiceProvider.notifier).addCurrency(coins);
      ref.read(likeGeniusServiceProvider.notifier).finishedPractice();
      dismiss();
    }
    return WillPopScope(
      onWillPop: () async {
        quit();
        return true;
      },
      child: Scaffold(
        body: SafeArea(
          child: Container(
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(30),
              color: Colors.white,
            ),
            child: Center(
              child: Stack(
                children: [
                  Align(
                    alignment: Alignment.bottomCenter,
                    child: Image.asset('assets/images/abstract-bg.png'),
                  ),
                  const ImageOrRive('assets/rive/completion-bg.riv',
                      stateMachine: 'State Machine 1'),
                  Column(
                    crossAxisAlignment: CrossAxisAlignment.center,
                    children: [
                      SizedBox(
                        height: S.x(2),
                      ),
                      AutoSizeText('Module 1 - Lesson 1',
                          style: Theme.of(context).textTheme.titleLarge!.copyWith(
                                fontSize: 20,
                                fontWeight: FontWeight.w700,
                              )),
                      AutoSizeText(
                        'Lesson Complete!',
                        style: Theme.of(context).textTheme.titleLarge!.copyWith(
                              fontSize: 50,
                              fontWeight: FontWeight.w800,
                            ),
                      ),
                      Image.asset('assets/tablet/completion_star.png',
                          height: 50, width: 50, fit: BoxFit.contain),
                      SizedBox(
                        height: MediaQuery.of(context).size.height / 3,
                        width: 300,
                        child: Center(
                          child: ImageOrRive(
                            usedCharacter,
                            stateMachine: 'State Machine 1',
                            triggers: ['Idle', 'Success 1'],
                            currentTrigger: characterTrigger,
                            onLoaded: () {
                              Future.delayed(const Duration(milliseconds: 500), () {
                                characterTriggerState.value = 'Success 1';
                              });
                            },
                            alignment: Alignment.topCenter,
                            fit: BoxFit
                                .fitHeight, 
                          ),
                        ),
                      ),
                      Expanded(
                        child: Container(
                          decoration: BoxDecoration(
                            borderRadius: BorderRadius.circular(16),
                            color: Colors.white,
                            boxShadow: [
                              BoxShadow(
                                color: Colors.grey.withOpacity(0.5),
                                spreadRadius: 5,
                                blurRadius: 7,
                                offset: const Offset(0, 3), 
                              ),
                            ],
                          ),
                          margin: EdgeInsets.symmetric(vertical: S.x(2), horizontal: S.x(30)),
                          padding: EdgeInsets.symmetric(vertical: S.x(2), horizontal: S.x(5)),
                          child: Column(
                            children: [
                              Expanded(
                                  child: Stack(
                                children: [
                                  Align(
                                    alignment: Alignment.topRight,
                                    child: Image.asset('assets/tablet/robot_ai.png',
                                        width: 80, height: 80, fit: BoxFit.fill),
                                  ),
                                  DefaultTabController(
                                    length: 1,
                                    child: Tabs(
                                      tabs: ['VOCAB'],
                                      children: [
                                        VocabTab(
                                          result: result,
                                        ),
                                      ],
                                    ),
                                  )
                                ],
                              )),
                              GeniusButton(
                                expanded: false,
                                style: GeniusButtonStyle.dark,
                                onPressed: onDismiss,
                                padding: EdgeInsets.symmetric(vertical: S.x2, horizontal: S.x(30)),
                                child: Text('', 
                                    style: Theme.of(context).textTheme.titleLarge!.copyWith(
                                          color: Colors.white,
                                          fontSize: 22,
                                          fontWeight: FontWeight.w700,
                                        )),
                              ),
                            ],
                          ),
                        ),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}
class ScoreTab extends StatelessWidget {
  const ScoreTab({
    super.key,
    required this.coins,
    required this.rewards,
  });
  final int coins;
  final List<ExerciseReward> rewards;
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        SizedBox(
          height: S.x(5),
        ),
        DefaultTextStyle(
          style: Theme.of(context).textTheme.titleLarge!.copyWith(
                fontSize: 30,
                fontWeight: FontWeight.w900,
              ),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const Text('+'),
              SizedBox(
                width: 70,
                child: Text(
                  coins.toString(),
                  textAlign: TextAlign.end,
                ),
              ),
              SizedBox(
                width: S.x(4),
              ),
              Image.asset(
                'assets/icons/genius-currency-icon.png',
                height: 40,
              ),
            ],
          ),
        ),
        SizedBox(
          height: S.x(5),
        ),
        Expanded(
          child: SingleChildScrollView(
            child: Padding(
              padding: const EdgeInsets.symmetric(horizontal: S.x5, vertical: 5),
              child: Column(
                children: [
                  for (final reward in rewards) ...[
                    Row(
                      children: [
                        Image.asset(reward.image, width: 25),
                        SizedBox(
                          width: S.x(2),
                        ),
                        Text(
                          '+${reward.coins}',
                          style: Theme.of(context).textTheme.titleSmall!.copyWith(
                                fontWeight: FontWeight.normal,
                              ),
                        ),
                        SizedBox(
                          width: S.x(3),
                        ),
                        Expanded(
                          child: Text(
                            reward.sentence,
                            style: Theme.of(context).textTheme.titleSmall!.copyWith(
                                  fontWeight: FontWeight.normal,
                                ),
                          ),
                        ),
                      ],
                    ),
                    SizedBox(
                      height: S.x(2),
                    )
                  ],
                ],
              ),
            ),
          ),
        ),
      ],
    );
  }
}
class VocabTab extends HookWidget {
  final SectionResult result;
  const VocabTab({
    super.key,
    required this.result,
  });
  @override
  Widget build(BuildContext context) {
    return SingleChildScrollView(
      padding: const EdgeInsets.only(left: 40, bottom: 10),
      child: Wrap(
        crossAxisAlignment: WrapCrossAlignment.center,
        spacing: 40,
        runSpacing: 20,
        children: [
          for (var exercise in result.exercises) ...[
            Container(
              decoration: const BoxDecoration(
                  color: Colors.transparent,
                  border: Border(
                    bottom: BorderSide(width: 1, color: C.GENIUS_GREY),
                  )),
              padding: const EdgeInsets.all(10.0),
              child: Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Column(
                    mainAxisSize: MainAxisSize.min,
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          const SizedBox(
                            width: S.half,
                          ),
                          AutoSizeText(
                            exercise.correctAnswer.content,
                            style: Theme.of(context).textTheme.bodyLarge!.copyWith(
                                  fontWeight: FontWeight.bold,
                                ),
                            maxLines: 3,
                            overflow: TextOverflow.ellipsis,
                          ),
                        ],
                      ),
                      const SizedBox(
                        height: S.half,
                      ),
                      Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          SizedBox(
                            width: 18,
                            height: 18,
                            child: CircularProgressIndicator(
                              strokeWidth: 5,
                              value: 1,
                              color: exercise.success ? C.GENIUS_SUCCESS : C.GENIUS_ERROR,
                            ),
                          ),
                          SizedBox(
                            width: S.x(2),
                          ),
                          AutoSizeText(
                            exercise.correctAnswer.translation ?? exercise.correctAnswer.content,
                            maxLines: 3,
                            overflow: TextOverflow.ellipsis,
                          ),
                        ],
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ],
        ],
      ),
    );
  }
}
---
Path: /lib/pages/exercises/conversation.dart

import 'package:auto_size_text/auto_size_text.dart';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:flutter_spinkit/flutter_spinkit.dart';
import 'package:twins/models/api/chat_request.dart';
import 'package:twins/models/api/lesson_request.dart';
import 'package:twins/style/values.dart';
import 'package:twins/widgets/chat_message_bubble.dart';
import 'package:twins/widgets/chat_scroll_view.dart';
import 'package:twins/widgets/never_avoid_fullscreen_area.dart';
class Conversation extends HookWidget {
  const Conversation({
    Key? key,
    required this.messages,
    required this.isTyping,
  }) : super(key: key);
  final bool isTyping;
  final List<ChatExchange> messages;
  @override
  Widget build(BuildContext context) {
    final currentPageState = useState(0);
    final currentPage = currentPageState.value;
    final pageController = usePageController(initialPage: 0);
    late ChatExchange? lastAssistantMessage;
    try {
      lastAssistantMessage =
          messages.lastWhere((element) => element.role == ChatSenderType.assistant);
    } catch (e) {
      lastAssistantMessage = null;
    }
    late ChatExchange? lastUserMessage;
    try {
      lastUserMessage = messages.lastWhere((element) =>
          element.role == ChatSenderType.user && element.type == ChatMessageType.message);
    } catch (e) {
      lastUserMessage = null;
    }
    return LayoutBuilder(
      builder: (context, constraints) {
        return Stack(
          clipBehavior: Clip.none,
          children: [
            Padding(
              padding: EdgeInsets.only(left: S.x(18.5)) + const EdgeInsets.only(top: 10),
              child: PageView(
                onPageChanged: (index) {
                  currentPageState.value = index;
                },
                controller: pageController,
                children: [
                  Stack(
                    children: [
                      Positioned(
                        top: 60,
                        child: NeverAvoidFullscreenArea(
                          width: constraints.maxWidth,
                          height: constraints.maxHeight,
                          child: Stack(
                            fit: StackFit.expand,
                            alignment: Alignment.center,
                            children: [
                              AnimatedCrossFade(
                                  duration: const Duration(milliseconds: 200),
                                  crossFadeState: currentPage == 0 && !isTyping
                                      ? CrossFadeState.showFirst
                                      : CrossFadeState.showSecond,
                                  secondChild: isTyping
                                      ? const ChatMessageBubble(
                                          characterId: 'currentCharacterId',
                                          chat: ChatExchange(
                                            concept: TranslatedConcept(
                                              content: '',
                                            ),
                                            role: ChatSenderType.assistant,
                                            type: ChatMessageType.message,
                                          ),
                                          child: SizedBox(
                                            height: 20,
                                            child: SpinKitThreeBounce(
                                              color: C.GENIUS_PRIMARY,
                                              size: 24,
                                            ),
                                          ),
                                        )
                                      : Container(),
                                  firstChild: lastAssistantMessage == null
                                      ? Container()
                                      : ChatMessageBubble(
                                          characterId: 'currentCharacterId',
                                          chat: ChatExchange(
                                            concept: lastAssistantMessage.concept,
                                            role: ChatSenderType.assistant,
                                            type: ChatMessageType.message,
                                          ),
                                          showHelpers: true,
                                          child: AutoSizeText(lastAssistantMessage.concept.content),
                                        )
                                  ),
                            ],
                          ),
                        ),
                      ),
                      if (lastUserMessage != null)
                        Align(
                          alignment: Alignment.topRight,
                          child: Padding(
                            padding: EdgeInsets.symmetric(horizontal: S.x(15)),
                            child: ChatMessageBubble(
                              characterId: 'currentCharacterId',
                              chat: ChatExchange(
                                concept: lastUserMessage.concept,
                                role: ChatSenderType.user,
                                type: ChatMessageType.message,
                              ),
                              child: Text(lastUserMessage.concept.content),
                            ),
                          ),
                        ),
                    ],
                  ),
                  Column(
                    children: [
                      Expanded(
                        child: ChatScrollView(
                          characterId: 'currentCharacterId',
                          showHelpers: true,
                          messages: messages,
                          isAvatarTyping: isTyping,
                        ),
                      ),
                    ],
                  ),
                ],
              ),
            ),
            Positioned(
                top: MediaQuery.of(context).size.height / 3 - 160,
                right: -70,
                child: ElevatedButton(
                  onPressed: () {
                    if (currentPage == 0) {
                      pageController.animateToPage(1,
                          duration: const Duration(milliseconds: 300), curve: Curves.easeInOut);
                    } else {
                      pageController.animateToPage(0,
                          duration: const Duration(milliseconds: 300), curve: Curves.easeInOut);
                    }
                  },
                  style: ElevatedButton.styleFrom(
                    shape: const CircleBorder(),
                    padding: EdgeInsets.only(right: S.x(8)),
                    backgroundColor: C.GENIUS_WHITE.withOpacity(0.8),
                  ),
                  child: Container(
                    decoration: const BoxDecoration(
                      borderRadius: BorderRadius.only(
                        topLeft: Radius.circular(45),
                        bottomLeft: Radius.circular(45),
                      ),
                      color: Colors.transparent,
                    ),
                    margin: EdgeInsets.fromLTRB(0, S.x(15), S.x(6), S.x(15)),
                    padding: EdgeInsets.symmetric(horizontal: S.x(4), vertical: S.x(8)),
                    child: currentPage == 0
                        ? const ImageIcon(
                            AssetImage('assets/icons/note-icon.png'),
                            size: 30,
                            color: C.GENIUS_BLACK,
                          )
                        : const Icon(Icons.chat_bubble_outline, size: 30, color: C.GENIUS_BLACK),
                  ),
                )),
          ],
        );
      },
    );
  }
}
---
Path: /lib/pages/exercises/exercises_page.dart

import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:gap/gap.dart';
import 'package:twins/features/profile/presentation/providers/profile_provider.dart';
import 'package:twins/mixins/widget.dart';
import 'package:twins/models/api/exercise_request.dart';
import 'package:twins/models/api/lesson_request.dart';
import 'package:twins/models/api/section_request.dart';
import 'package:twins/models/results/exercise_result.dart';
import 'package:twins/models/results/section_result.dart';
import 'package:twins/pages/exercises/base_lesson_page.dart';
import 'package:twins/pages/exercises/widgets/exercises_content.dart';
import 'package:twins/providers/asset_or_network_file_provider.dart';
import 'package:twins/providers/exercise_result_repository_provider.dart';
import 'package:twins/providers/feedback_helper_provider.dart';
import 'package:twins/providers/tts_provider.dart';
import 'package:twins/services/audio_player_service.dart';
import 'package:twins/style/genius_button_style.dart';
import 'package:twins/style/values.dart';
import 'package:twins/widgets/core/genius_button.dart';
import 'package:twins/widgets/dialogs/missed_exercises_dialog.dart';
import 'package:twins/widgets/rive/image_or_rive.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:twins/widgets/toggle/toggle_global_sound.dart';
enum ExerciseMode {
  Mandatory,
  Missed,
}
class ExercisesPage extends HookConsumerWidget with PageWidget<SectionResult> {
  final SectionData section;
  final LessonData lesson;
  const ExercisesPage({required this.section, required this.lesson, Key? key}) : super(key: key);
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final exerciseModeState = useState(ExerciseMode.Mandatory);
    final exerciseMode = exerciseModeState.value;
    final mandatoryExercises = section.exercises;
    final mandatoryExercisesLength = mandatoryExercises.length;
    final currentMandatoryExerciseIndexState = useState(0);
    final currentMandatoryExerciseIndex = currentMandatoryExerciseIndexState.value;
    final currentMandatoryExercise = currentMandatoryExerciseIndex < mandatoryExercisesLength
        ? mandatoryExercises[currentMandatoryExerciseIndex]
        : null;
    final mandatoryExercisesEnded = currentMandatoryExerciseIndex >= mandatoryExercisesLength;
    final totalMandatorySteps = section.totalExercisesCount;
    final currentMandatoryStepState = useState(0);
    final currentMandatoryStep = currentMandatoryStepState.value;
    final mandatoryProgress = currentMandatoryStep / totalMandatorySteps;
    final currentMissedExerciseIndexState = useState(0);
    final currentMissedExerciseIndex = currentMissedExerciseIndexState.value;
    final missedExercisesState = useState<List<ExerciseData>>([]);
    final missedExercises = missedExercisesState.value;
    final missedExercisesLength = missedExercises.length;
    final missedExercisesEnded = currentMissedExerciseIndex >= missedExercisesLength;
    final currentMissedExercise = currentMissedExerciseIndex < missedExercisesLength
        ? missedExercises[currentMissedExerciseIndex]
        : null;
    final totalMissedSteps = missedExercises.length;
    final currentMissedStepState = useState(0);
    final currentMissedStep = currentMissedStepState.value;
    final missedProgress = totalMissedSteps != 0 ? currentMissedStep / totalMissedSteps : 0.0;
    var currentProgress =
        exerciseMode == ExerciseMode.Mandatory ? mandatoryProgress : missedProgress;
    final exercisesEnded = mandatoryExercisesEnded && missedExercisesEnded;
    final currentExercise = currentMandatoryExercise ?? currentMissedExercise;
    final exerciseResultsState = useState<List<ExerciseResult>>([]);
    final exerciseResults = exerciseResultsState.value;
    final exercisesDoneCount = exerciseResults.length;
    final exercisesSuccessCount = exerciseResults.where((e) => e.success).length;
    final preloadedDataRequest = ref.watch(preloadSectionProvider(section));
    final loadingDataSate = useState(true);
    final loadingData = loadingDataSate.value;
    final userCharacter = ref.watch(userProfileOrNullProvider)?.character;
    useEffect(() {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        preloadedDataRequest.when(
          data: (value) {
            loadingDataSate.value = false;
          },
          loading: () {
            loadingDataSate.value = true;
          },
          error: (error, stackTrace) {
            loadingDataSate.value = false;
          },
        );
      });
      return null;
    }, [preloadedDataRequest]);
    final characterIsLoadingState = useState(section.character != null);
    final characterIsLoading = characterIsLoadingState.value;
    final currentAnimationTriggerState = useState('self');
    final currentAnimationTrigger = currentAnimationTriggerState.value;
    final interlocutorAnimationTriggerState = useState<String?>('assets/rive/${section.character}');
    final interlocutorAnimationTrigger = interlocutorAnimationTriggerState.value;
    final interlocutorIsTalkingState = useState<Map<String, bool>>({'Idle': true});
    final interlocutorPlayingAudio =
        ref.watch(ttsNotifierProvider(AudioPlayerType.INTERLOCUTOR)) == AudioPlayerState.playing;
    final loading = characterIsLoading && loadingData;
    final feedbackHelper = ref.watch(feedbackHelperProvider.notifier);
    void setCharacterAnimation(String trigger, {bool resetToIdle = true, bool avatar = true}) {
      if (resetToIdle) {
        currentAnimationTriggerState.value = "Idle";
        interlocutorAnimationTriggerState.value = 'Discussion Loop';
      }
      WidgetsBinding.instance.addPostFrameCallback((_) async {
        if (avatar) {
          currentAnimationTriggerState.value = trigger;
        } else {
          interlocutorAnimationTriggerState.value = trigger;
        }
      });
    }
    void onProgress(ValueNotifier<int> stepState) {
      stepState.value++;
    }
    final sessionId = useState(DateTime.now().millisecondsSinceEpoch.toString());
    final stopwatchesState = useState<Map<int, Stopwatch>>({});
    useEffect(() {
      stopwatchesState.value[0] = Stopwatch()..start();
      return null;
    }, []);
    void onFinishedExercise(ValueNotifier<int> indexToUpdate, List<ExerciseResult?> results,
        {bool progress = true, addFailToResults = false}) {
      final currentIndex = indexToUpdate.value;
      final stopwatch = stopwatchesState.value[currentIndex];
      stopwatch?.stop();
      final responseTime = stopwatch?.elapsedMilliseconds.toDouble() ?? 0.0;
      indexToUpdate.value++;
      var nonNullResults = results.whereType<ExerciseResult>().toList();
      if (nonNullResults.isEmpty && progress) {
        onProgress(currentMandatoryStepState);
      }
      for (var result in nonNullResults) {
        final updatedResult = result.copyWith(
          responseTime: responseTime / 1000.0,
          categoryId: section.type.name,
          exerciseSessionId: sessionId.value,
        );
        ref.read(exerciseResultRepositoryProvider).submitResult(updatedResult);
        if (result.success || addFailToResults) {
          exerciseResultsState.value = [...exerciseResultsState.value, updatedResult];
        }
      }
      if (currentIndex + 1 <
          (exerciseMode == ExerciseMode.Mandatory
              ? mandatoryExercises.length
              : missedExercises.length)) {
        stopwatchesState.value[currentIndex + 1] = Stopwatch()..start();
      }
    }
    void onFinishedMandatoryExercise(List<ExerciseResult?> result, {bool progress = true}) async {
      final oneResult = result.isEmpty || result.length > 1 ? null : result.first;
      final missedExercise =
          oneResult != null && oneResult.success == false ? currentMandatoryExercise! : null;
      missedExercisesState.value = [
        ...missedExercises,
        if (missedExercise != null) missedExercise,
      ];
      final willBeLastMandatoryExercise =
          currentMandatoryExerciseIndex + 1 == mandatoryExercisesLength;
      final hasMissedExercises = missedExercises.isNotEmpty || missedExercise != null;
      if (willBeLastMandatoryExercise && hasMissedExercises) {
        await MissedExercisesDialog().show();
        exerciseModeState.value = ExerciseMode.Missed;
      }
      onFinishedExercise(currentMandatoryExerciseIndexState, result, progress: progress);
    }
    void onFinishedMissedExercise(List<ExerciseResult?> result, {bool progress = true}) {
      onFinishedExercise(currentMissedExerciseIndexState, result,
          progress: progress, addFailToResults: true);
    }
    void onConfirmedExercise(bool succeed) {
      setCharacterAnimation(succeed ? 'Idle' : 'Idle');
      setCharacterAnimation(succeed ? 'Success 2' : 'Wonder', avatar: false);
      if (succeed) {
        feedbackHelper.Success();
      } else {
        feedbackHelper.Failure();
      }
    }
    void onConfirmMandatoryExercise(bool succeed) {
      onProgress(currentMandatoryStepState);
      onConfirmedExercise(succeed);
    }
    void onConfirmMissedExercise(bool succeed) {
      onProgress(currentMissedStepState);
      onConfirmedExercise(succeed);
    }
    useEffect(() {
      if (exercisesEnded) {
        setCharacterAnimation('Happy');
        setCharacterAnimation('Wonder', avatar: false);
      }
      return null;
    }, [exercisesEnded]);
    useEffect(() {
      interlocutorIsTalkingState.value = {'Success 2': interlocutorPlayingAudio};
      return null;
    }, [interlocutorPlayingAudio]);
    return BaseLessonPage(
      exerciseFullScreen: currentExercise?.fullScreen ?? false,
      bodypadding: EdgeInsets.zero,
      loading: loading,
      background: section.background,
      character: section.character != null
          ? ImageOrRive(
              'Hello',
              stateMachine: 'Discussion Loop',
              triggers: [
                'assets/rive/girl_city.riv',
                'State Machine 1',
                'Idle',
                "Wonder",
                "Success 2"
              ],
              currentTrigger: interlocutorAnimationTrigger,
              triggerBools: {"Hello": true},
              currentBoolsTriggers: interlocutorIsTalkingState.value,
              onLoaded: () {
                characterIsLoadingState.value = false;
              },
            )
          : null,
      onLeave: dismiss,
      progress: currentProgress,
      topRightContent: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          ClipOval(
            child: Container(
              color: Colors.white,
              width: 150,
              height: 150,
              child: Transform.translate(
                offset: const Offset(4, 40),
                child: Transform.scale(
                  scale: 1.3,
                  child: ImageOrRive(
                    userCharacter!,
                    stateMachine: "Happy",
                    triggers: ['Discussion Loop', 'State Machine 1', 'Idle'],
                    currentTrigger: currentAnimationTrigger,
                    alignment: Alignment.topLeft,
                    fit: BoxFit.cover,
                  ),
                ),
              ),
            ),
          ),
          const Gap(S.x1),
          const ToggleGlobalSound(),
        ],
      ),
      children: [
        if (!mandatoryExercisesEnded && !loading && exerciseMode == ExerciseMode.Mandatory)
          Expanded(
            child: ExercisesContent(
              key: const Key('Success 2'),
              lesson: lesson,
              exercises: mandatoryExercises,
              onClose: dismiss,
              onFinishedExercise: onFinishedMandatoryExercise,
              onConfirmedExercise: onConfirmMandatoryExercise,
            ),
          ),
        if (!missedExercisesEnded && !loading && exerciseMode == ExerciseMode.Missed) ...[
          Expanded(
            child: ExercisesContent(
              key: const Key('Wonder'),
              lesson: lesson,
              exercises: missedExercises,
              onClose: dismiss,
              onFinishedExercise: onFinishedMissedExercise,
              onConfirmedExercise: onConfirmMissedExercise,
            ),
          ),
        ],
        if (exercisesEnded) ...[
          const Spacer(),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 20.0),
            child: GeniusButton(
              expanded: true,
              style: GeniusButtonStyle.dark,
              onPressed: () {
                SectionResult practiceResult = SectionResult(
                  score: exercisesSuccessCount / exercisesDoneCount,
                  exercises: exerciseResults,
                );
                feedbackHelper.Finish();
                dismiss(practiceResult);
              },
              child: const Text('mandatory_exercises'),
            ),
          ),
        ],
        SizedBox(
          height: S.x(3),
        )
      ],
    );
  }
}
---
Path: /lib/pages/exercises/lesson_test_page.dart

import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:twins/features/profile/presentation/providers/profile_provider.dart';
import 'package:twins/mixins/widget.dart';
import 'package:twins/models/api/chat_request.dart';
import 'package:twins/models/api/lesson_request.dart';
import 'package:twins/models/notification_panel_model.dart';
import 'package:twins/models/results/exercise_result.dart';
import 'package:twins/models/results/section_result.dart';
import 'package:twins/providers/genius_api_provider.dart';
import 'package:twins/providers/tts_provider.dart';
import 'package:twins/services/audio_player_service.dart';
import 'package:twins/services/notifications_panel_service.dart';
import 'package:twins/style/genius_button_style.dart';
import 'package:twins/style/values.dart';
import 'package:twins/widgets/chat/chat_area.dart';
import 'package:twins/widgets/core/genius_button.dart';
import 'package:twins/widgets/core/genius_rounded_square_button.dart';
import 'package:twins/widgets/core/notifications/notifications_manager.dart';
import 'package:twins/widgets/rive/image_or_rive.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'base_lesson_page.dart';
import 'conversation.dart';
import 'exercise_widgets/vocabulary_dialog.dart';
class LessonTestPage extends HookConsumerWidget with PageWidget<SectionResult> {
  final LessonData lesson;
  final int maxMessages;
  const LessonTestPage({required this.lesson, required this.maxMessages});
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final messagesState = useState(<ChatExchange>[]);
    final messages = messagesState.value;
    final isTypingState = useState(false);
    final isTyping = isTypingState.value;
    final userEditState = useState(true);
    final tts = ref.watch(ttsNotifierProvider(AudioPlayerType.INTERLOCUTOR).notifier);
    final userMessageCount = messages
        .where((element) =>
            element.role == ChatSenderType.user && element.type == ChatMessageType.message)
        .length;
    final isEnded = userMessageCount >= maxMessages;
    final usedConceptsState = useState(<TranslatedConcept>[]);
    final usedConcepts = usedConceptsState.value;
    final characterIsLoadingState = useState(true);
    final characterIsLoading = characterIsLoadingState.value;
    final userCharacter = ref.watch(userProfileOrNullProvider)?.character;
    final usedCharacter = userCharacter ?? 'assets/rive/character.riv';
    void playAudio(String text) async {
      String characterId = 'currentCharacterId';
      await tts.playAudio(text, characterId);
    }
    double getProgression() {
      if (userMessageCount == 0) {
        return 0;
      }
      if (userMessageCount >= maxMessages) {
        return 1;
      }
      return userMessageCount / maxMessages;
    }
    List<ChatExchange> addMessages(List<ChatExchange> messages, [bool fromResponse = false]) {
      if (fromResponse) {
        final assistantReply =
            messages.lastWhere((element) => element.role == ChatSenderType.assistant);
        playAudio(assistantReply.concept.content);
      }
      final newArray = [
        ...messagesState.value,
        ...messages,
      ];
      messagesState.value = newArray;
      return newArray;
    }
    void sendMessage(String message) async {
      for (var concept in []) {
        if (message.toLowerCase().contains(concept.content.toLowerCase())) {
          if (usedConcepts.contains(concept)) {
            continue;
          }
          ref
              .read(notificationsPanelServiceProvider.notifier)
              .addNotificationPanelData(NotificationPanelType.success, const Text("Nice"));
          usedConceptsState.value = [...usedConceptsState.value, concept];
        }
      }
      isTypingState.value = true;
      userEditState.value = false;
      final newArray = addMessages([
        ChatExchange(
          concept: TranslatedConcept(
            content: message,
          ),
          role: ChatSenderType.user,
          type: ChatMessageType.message,
        ),
      ]);
      if (userMessageCount + 1 >= maxMessages) {
        return;
      }
      try {
        final response = await ref.read(geniusRepositoryProvider).postChat(newArray, '');
        addMessages(response.replies, true);
      } finally {
        isTypingState.value = false;
      }
    }
    useEffect(() {
      WidgetsBinding.instance.addPostFrameCallback((_) async {
      });
      return null;
    }, []);
    void onDismiss() {
      List<ExerciseResult> exerciseResults = [];
      int exercisesDoneCount = 0;
      int exercisesSuccessCount = 0;
      if (isEnded) {
        for (final concept in []) {
          bool succeed = usedConcepts.contains(concept);
          final exerciseResult = ExerciseResult(
            correctAnswer: concept,
            userInput: succeed ? concept : null,
            success: succeed,
            exerciseId: TranslatedConcept(content: concept).id,
          );
          exerciseResults.add(exerciseResult);
          if (succeed) {
            exercisesSuccessCount++;
          }
        }
      }
      SectionResult practiceResult = SectionResult(
        score: exercisesSuccessCount / exercisesDoneCount,
        exercises: exerciseResults,
      );
      dismiss(isEnded ? practiceResult : null);
    }
    return Stack(
      children: [
        BaseLessonPage(
          loading: characterIsLoading,
          topRightContent: GeniusRoundedSquareButton(
            style: GeniusButtonStyle.light,
            size: 40,
            radius: 100,
            onTap: () async {
              await VocabularyDialog(
                notUsedConcepts: [],
                usedConcepts: usedConcepts,
              ).show();
            },
            child: const Icon(
              Icons.list,
            ),
          ),
          background: null,
          character: ImageOrRive(
            usedCharacter,
            stateMachine: 'State Machine 1',
            onLoaded: () {
              characterIsLoadingState.value = false;
            },
          ),
          progress: getProgression(),
          onLeave: onDismiss,
          bodypadding: EdgeInsets.zero,
          children: [
            Expanded(
              child: Conversation(
                messages: messages,
                isTyping: isTyping && !isEnded,
              ),
            ),
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: S.x3),
              child: Column(
                children: [
                  if (!isEnded)
                    Column(
                      children: [
                        if (!isEnded)
                          ChatArea(
                            onMessage: (message) async {
                              sendMessage(message);
                            },
                          ),
                      ],
                    ),
                  if (isEnded)
                    GeniusButton(
                      style: GeniusButtonStyle.dark,
                      onPressed: onDismiss,
                      child: const Text('END'),
                    ),
                  const SizedBox(
                    height: S.x2,
                  ),
                ],
              ),
            ),
          ],
        ),
        NotificationsManager(),
      ],
    );
  }
}
---
Path: /lib/pages/exercises/widgets/exercises_content.dart

import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:twins/models/api/exercise_request.dart';
import 'package:twins/models/api/lesson_request.dart';
import 'package:twins/models/results/exercise_result.dart';
import 'package:twins/pages/exercises/exercise_widgets/explanation_widget.dart';
import 'package:twins/pages/exercises/exercise_widgets/listening_widget.dart';
import 'package:twins/pages/exercises/exercise_widgets/reading_widget.dart';
import 'package:twins/pages/exercises/exercise_widgets/scripted_conversation_widget.dart';
import 'package:twins/pages/exercises/exercise_widgets/vocabulary_acquisition_widget.dart';
import 'package:twins/pages/exercises/exercise_widgets/vocabulary_practice_widget.dart';
import 'package:twins/pages/exercises/exercise_widgets/word_completion_widget.dart';
import 'package:twins/pages/exercises/exercise_widgets/word_reordering_widget.dart';
import 'package:twins/style/genius_button_style.dart';
import 'package:twins/widgets/core/genius_button.dart';
class ExercisesContent extends HookWidget {
  const ExercisesContent({
    Key? key,
    required this.lesson,
    required this.exercises,
    required this.onFinishedExercise,
    required this.onConfirmedExercise,
    required this.onClose,
  }) : super(key: key);
  final LessonData lesson;
  final List<ExerciseData> exercises;
  final void Function(List<ExerciseResult?> results, {bool progress}) onFinishedExercise;
  final void Function(bool succeed) onConfirmedExercise;
  final void Function() onClose;
  @override
  Widget build(BuildContext context) {
    final pageViewController = usePageController(initialPage: 0, viewportFraction: 1.5);
    final exercisesLength = exercises.length;
    final currentExerciseIndexState = useState(0);
    void finishedExercise(List<ExerciseResult?> results, {bool progress = true}) {
      if (currentExerciseIndexState.value + 1 < exercisesLength) {
        currentExerciseIndexState.value++;
        pageViewController.nextPage(
          duration: const Duration(milliseconds: 800),
          curve: Curves.easeOutCirc,
        );
      }
      onFinishedExercise(results, progress: progress);
    }
    return PageView.builder(
      physics: const NeverScrollableScrollPhysics(),
      controller: pageViewController,
      itemCount: exercisesLength,
      itemBuilder: (context, index) => FractionallySizedBox(
        widthFactor: 1 / pageViewController.viewportFraction,
        child: exercises[index].map(
          vocabularyAcquisition: (ex) => VocabularyAcquisitionWidget(
            exercise: ex.vocabularyAcquisition,
            onFinishedExercise: finishedExercise,
            key: Key(ex.vocabularyAcquisition.concept.content),
          ),
          vocabularyPractice: (ex) => VocabularyPracticeWidget(
            exercise: ex.vocabularyPractice,
            onFinishedExercise: finishedExercise,
            onConfirmedExercise: onConfirmedExercise,
            key: Key(ex.vocabularyPractice.concept.content),
          ),
          wordReordering: (ex) => WordReorderingWidget(
            exercise: ex.wordReordering,
            onFinishedExercise: finishedExercise,
            onConfirmedExercise: onConfirmedExercise,
          ),
          wordCompletion: (ex) => WordCompletionWidget(
            exercise: ex.wordCompletion,
            onFinishedExercise: finishedExercise,
            onConfirmedExercise: onConfirmedExercise,
            key: Key(ex.wordCompletion.concept.content),
          ),
          reading: (ex) => ReadingWidget(
            exercise: ex.reading,
            onFinishedExercise: finishedExercise,
            onConfirmedExercise: onConfirmedExercise,
            key: Key(ex.reading.concept.content),
          ),
          listening: (value) => ListeningWidget(
            exercise: value.listening,
            onFinishedExercise: finishedExercise,
            onConfirmedExercise: onConfirmedExercise,
            key: Key(value.listening.concept.content),
          ),
          scriptedConversation: (ex) => ScriptedConversationWidget(
            exercise: ex.scriptedConversation,
            onFinishedExercise: finishedExercise,
            onConfirmedExercise: onConfirmedExercise,
          ),
          explanation: (ex) => ExplanationWidget(
            lesson: lesson,
            exercise: ex.explanation,
            onFinishedExercise: finishedExercise,
            onConfirmedExercise: onConfirmedExercise,
            onClose: onClose,
          ),
          unknown: (ex) => Column(
            children: [
              const Spacer(),
              RichText(
                  textAlign: TextAlign.center,
                  text: TextSpan(
                      style: const TextStyle(
                        color: Colors.black,
                        fontSize: 20,
                      ),
                      children: [
                        const TextSpan(text: 'Sorry, '),
                        const TextSpan(
                          text: 'Genius',
                          style: TextStyle(
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                        const TextSpan(text: ' does not know this exercise yet.'),
                        const TextSpan(text: "\n\nYou may need to update your app."),
                        TextSpan(
                            text: "\n\nOr you can skip.",
                            style: TextStyle(color: Colors.grey[600])),
                      ])),
              const Spacer(),
              GeniusButton(
                style: GeniusButtonStyle.dark,
                onPressed: () {
                  finishedExercise([null]);
                },
                child: const Text('Skip'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
---
Path: /lib/pages/exercises/exercise_widgets/card_content.dart

import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:twins/models/api/lesson_request.dart';
import 'package:twins/widgets/rive/image_or_rive.dart';
class FrontCardContent extends HookWidget {
  final TranslatedConcept concept;
  final void Function()? onTap;
  const FrontCardContent({
    Key? key,
    required this.concept,
    this.onTap,
  }) : super(key: key);
  @override
  Widget build(BuildContext context) {
    return Card(
      elevation: 1,
      child: ClipRRect(
        borderRadius: BorderRadius.circular(16),
        child: Stack(
          fit: StackFit.expand,
          children: [
            if (concept.image != null)
              ImageOrRive(
                concept.image!,
                fit: BoxFit.cover,
                stateMachine: 'State Machine 1',
              ),
            Align(
              alignment: Alignment.bottomCenter,
              child: Container(
                decoration: BoxDecoration(
                  gradient: LinearGradient(
                    begin: Alignment.topCenter,
                    end: Alignment.bottomCenter,
                    colors: [
                      Colors.black.withOpacity(0.0),
                      Colors.black.withOpacity(0.5),
                    ],
                  ),
                ),
                width: double.infinity,
                height: 70,
                child: Center(
                  child: Center(
                    child: Text(concept.translation ?? concept.content,
                        style: Theme.of(context).textTheme.titleLarge!.copyWith(
                              color: Colors.white,
                            )),
                  ),
                ),
              ),
            ),
            if (onTap != null)
              Positioned.fill(
                child: Material(
                  color: Colors.transparent,
                  child: InkWell(
                    onTap: onTap,
                  ),
                ),
              ),
          ],
        ),
      ),
    );
  }
}
class BackCardContent extends HookWidget {
  final TranslatedConcept concept;
  final void Function()? onTap;
  const BackCardContent({
    Key? key,
    required this.concept,
    this.onTap,
  }) : super(key: key);
  @override
  Widget build(BuildContext context) {
    return Card(
      elevation: 1,
      child: ClipRRect(
        borderRadius: BorderRadius.circular(16),
        child: Material(
          child: InkWell(
            onTap: onTap,
            child: SizedBox(
              width: double.infinity,
              child: Padding(
                padding: const EdgeInsets.all(8.0),
                child: Center(
                    child: Text(
                  concept.content,
                  style: Theme.of(context).textTheme.titleLarge,
                )),
              ),
            ),
          ),
        ),
      ),
    );
  }
}
---
Path: /lib/pages/exercises/exercise_widgets/explanation_widget.dart

import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:twins/features/profile/presentation/providers/profile_provider.dart';
import 'package:twins/models/api/exercise_request.dart';
import 'package:twins/models/api/lesson_request.dart';
import 'package:twins/models/results/exercise_result.dart';
import 'package:twins/style/genius_button_style.dart';
import 'package:twins/style/values.dart';
import 'package:twins/widgets/core/genius_button.dart';
import 'package:twins/widgets/core/genius_rounded_square_button.dart';
import 'package:twins/widgets/rive/image_or_rive.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:gap/gap.dart';
class ExplanationWidget extends HookConsumerWidget {
  const ExplanationWidget({
    required this.lesson,
    required this.exercise,
    required this.onFinishedExercise,
    required this.onConfirmedExercise,
    required this.onClose,
    Key? key,
  }) : super(key: key);
  final LessonData lesson;
  final ExplanationData exercise;
  final Function(List<ExerciseResult?> result, {bool progress}) onFinishedExercise;
  final Function(bool) onConfirmedExercise;
  final VoidCallback onClose;
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final userCharacter = ref.watch(userProfileOrNullProvider)?.character;
    final hasReadAllState = useState(false);
    final hasReadAll = hasReadAllState.value;
    final usedCharacter = userCharacter ?? 'assets/rive/character.riv';
    void finishedExercise() {
      onFinishedExercise([], progress: false);
    }
    void next() {
      finishedExercise();
    }
    return Stack(
      clipBehavior: Clip.none,
      fit: StackFit.expand,
      children: [
        const ImageOrRive(
          'assets/rive/dots-launch.riv',
          stateMachine: 'State Machine 1',
          fit: BoxFit.cover,
          alignment: Alignment.topLeft,
        ),
        Positioned(
          top: 100, 
          left: 0,
          right: 0,
          bottom: 0,
          child: Align(
            child: SizedBox(
              height: 500,
              child: ImageOrRive(
                usedCharacter,
                stateMachine: 'State Machine 1',
                triggers: ['Idle'],
                currentTrigger: null,
              ),
            ),
          ),
        ),
        Padding(
          padding: const EdgeInsets.symmetric(horizontal: 20.0),
          child: Column(
            mainAxisSize: MainAxisSize.max,
            children: [
              Stack(
                children: [
                  SizedBox(
                    width: double.infinity,
                    child: Column(
                      children: [
                        Row(
                          mainAxisAlignment: MainAxisAlignment.spaceBetween,
                          crossAxisAlignment: CrossAxisAlignment.center,
                          children: [
                            GeniusRoundedSquareButton(
                              radius: 100,
                              onTap: onClose,
                              style: GeniusButtonStyle.transparent,
                              child: const Padding(
                                padding: EdgeInsets.only(left: 3.0),
                                child: Icon(
                                  Icons.close,
                                  size: 50,
                                ),
                              ),
                            ),
                            Row(
                              children: [
                                Container(
                                  padding: const EdgeInsets.symmetric(vertical: 4, horizontal: 12),
                                  width: 200,
                                  decoration: BoxDecoration(
                                    color: const Color(0xFFBB78DA),
                                    borderRadius: BorderRadius.circular(100),
                                  ),
                                  child: const Center(
                                    child: Text(
                                      "Eiken 5",
                                      style: TextStyle(
                                          color: Colors.white,
                                          fontSize: 20,
                                          fontWeight: FontWeight.w700),
                                    ),
                                  ),
                                ),
                                const Gap(16),
                                Container(
                                  padding: const EdgeInsets.symmetric(vertical: 4, horizontal: 12),
                                  width: 200,
                                  decoration: BoxDecoration(
                                    color: const Color(0xFFFFCD7F),
                                    borderRadius: BorderRadius.circular(100),
                                  ),
                                  child: const Center(
                                    child: Text(
                                      "7 words",
                                      style: TextStyle(
                                          color: Colors.white,
                                          fontSize: 20,
                                          fontWeight: FontWeight.w700),
                                    ),
                                  ),
                                ),
                              ],
                            ),
                            Align(
                              alignment: Alignment.topRight,
                              child: TextButton(
                                onPressed: finishedExercise,
                                child: Padding(
                                  padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 12),
                                  child: Text(
                                    "Skip",
                                    style: Theme.of(context)
                                        .textTheme
                                        .bodyLarge
                                        ?.copyWith(color: C.GENIUS_GREY_DARK),
                                  ),
                                ),
                              ),
                            ),
                          ],
                        ),
                        const Gap(S.x2),
                        Center(
                          child: Text(
                            lesson.title,
                            style: Theme.of(context)
                                .textTheme
                                .titleLarge
                                ?.copyWith(fontSize: 70, fontWeight: FontWeight.w700),
                          ),
                        ),
                        Center(
                          child: Text(
                            lesson.description,
                            style: Theme.of(context).textTheme.titleLarge?.copyWith(
                                  fontSize: 30,
                                  color: const Color(0xFF776C6C),
                                ),
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
              const Gap(S.x2),
              const Spacer(),
              SizedBox(
                width: 400,
                child: GeniusButton(
                  expanded: true,
                  style: GeniusButtonStyle.dark,
                  onPressed: () {
                    next();
                  },
                  child: const Text("Next"),
                ),
              ),
            ],
          ),
        ),
        TextBubble(
            texts: exercise.texts,
            onFinished: () {
              hasReadAllState.value = true;
            }),
      ],
    );
  }
}
class TextBubble extends HookWidget {
  final List<TranslatedConcept> texts;
  final Function? onFinished;
  const TextBubble({required this.texts, this.onFinished});
  @override
  Widget build(BuildContext context) {
    final index = useState<int>(0);
    final canGoNext = index.value < texts.length - 1;
    final canGoPrev = index.value > 0;
    void next() {
      if (index.value == texts.length - 2) {
        onFinished?.call();
      }
      if (index.value < texts.length - 1) {
        index.value++;
      }
    }
    void prev() {
      if (index.value > 0) {
        index.value--;
      }
    }
    return Positioned(
      right: 10,
      bottom: MediaQuery.of(context).size.height * 0.55, 
      child: Stack(
        children: [
          Positioned(
            child: ConstrainedBox(
              constraints: BoxConstraints(
                maxWidth: MediaQuery.of(context).size.width * 0.4,
              ),
              child: Column(
                children: [
                  Container(
                    padding: const EdgeInsets.all(16) + const EdgeInsets.only(bottom: 10),
                    decoration: BoxDecoration(
                      boxShadow: [
                        BoxShadow(
                          color: Colors.black.withOpacity(0.3),
                          spreadRadius: 1,
                          blurRadius: 5,
                          offset: const Offset(0, 2), 
                        ),
                      ],
                      color: Colors.grey[100],
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Align(
                      alignment: Alignment.bottomLeft, 
                      child: Text(
                        texts[index.value].content,
                        style: const TextStyle(color: Colors.black),
                      ),
                    ),
                  ),
                  Container(
                    height: 15,
                  )
                ],
              ),
            ),
          ),
          Positioned(
            right: 0,
            left: 0,
            bottom: 0, 
            child: Row(
              mainAxisSize: MainAxisSize.max,
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                GeniusRoundedSquareButton(
                  radius: 100,
                  size: 30,
                  onTap: prev,
                  style: canGoPrev ? GeniusButtonStyle.dark : GeniusButtonStyle.greyLight,
                  child: const Padding(
                    padding: EdgeInsets.only(left: 7.0),
                    child: Icon(
                      Icons.arrow_back_ios,
                      size: 18,
                    ),
                  ),
                ),
                const Gap(50),
                GeniusRoundedSquareButton(
                  radius: 100,
                  size: 30,
                  onTap: next,
                  style: canGoNext ? GeniusButtonStyle.dark : GeniusButtonStyle.greyLight,
                  child: const Padding(
                    padding: EdgeInsets.only(left: 3.0),
                    child: Icon(
                      Icons.arrow_forward_ios,
                      size: 18,
                    ),
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}
---
Path: /lib/pages/exercises/exercise_widgets/listening_widget.dart

import 'dart:typed_data';
import 'package:auto_size_text/auto_size_text.dart';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:flutter_spinkit/flutter_spinkit.dart';
import 'package:twins/components/app_asset.dart';
import 'package:twins/components/static_decoration.dart';
import 'package:twins/models/api/exercise_request.dart';
import 'package:twins/models/results/exercise_result.dart';
import 'package:twins/notifiers/setting_notifier.dart';
import 'package:twins/pages/exercises/exercise_widgets/multiple_choice.dart';
import 'package:twins/providers/asset_or_network_file_provider.dart';
import 'package:twins/services/audio_player_service.dart';
import 'package:twins/style/genius_button_style.dart';
import 'package:twins/style/values.dart';
import 'package:twins/utilities/snack_bar_helper.dart';
import 'package:twins/widgets/core/genius_rounded_square_button.dart';
import 'package:twins/widgets/rive/image_or_rive.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
class ListeningWidget extends HookConsumerWidget {
  const ListeningWidget({
    required this.exercise,
    required this.onFinishedExercise,
    required this.onConfirmedExercise,
    Key? key,
  }) : super(key: key);
  final ListeningData exercise;
  final Function(List<ExerciseResult?> results) onFinishedExercise;
  final Function(bool) onConfirmedExercise;
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final byteDataRequest = ref.watch(assetOrNetworkFileProvider(exercise.audio));
    final audioPlayerService =
        ref.watch(audioPlayerServiceProvider(AudioPlayerType.EXERCISE).notifier);
    final audioExerciseIsPlaying =
        ref.watch(audioPlayerServiceProvider(AudioPlayerType.EXERCISE)) == AudioPlayerState.playing;
    final byteData = useState<ByteData?>(null);
    final loadingState = useState(true);
    final loading = loadingState.value;
    final playedAmountState = useState(0);
    final playedAmount = playedAmountState.value;
    final canReplay = playedAmount <= 1;
    final hasPlayed = playedAmount > 0;
    final globalSoundEnabled = ref.watch(settingNotifierProvider).globalSoundEnabled;
    void finishedExercise(ExerciseResult? result) {
      onFinishedExercise([result]);
    }
    useEffect(() {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        byteDataRequest.when(
          data: (value) {
            byteData.value = value;
            loadingState.value = false;
          },
          loading: () {
            loadingState.value = true;
          },
          error: (error, stackTrace) {
            loadingState.value = false;
            SnackbarHelper.showError(context, "Could not load audio file");
          },
        );
      });
      return null;
    }, [byteDataRequest]);
    useEffect(() {
      return () {
        audioPlayerService.stop();
      };
    }, []);
    return Padding(
      padding: EdgeInsets.symmetric(horizontal: S.x(18.5)),
      child: Column(
        mainAxisSize: MainAxisSize.max,
        children: [
          Align(
            alignment: Alignment.centerLeft,
            child: Text.rich(TextSpan(children: [
              TextSpan(
                  text: '',
                  style: Theme.of(context)
                      .textTheme
                      .titleLarge
                      ?.copyWith(fontSize: 30, color: const Color(0xFF1D1C1C))),
              const WidgetSpan(child: width15),
              WidgetSpan(
                  child: Image.asset(AppAsset.listeningIcon, height: 30, fit: BoxFit.fitHeight))
            ])),
          ),
          if (exercise.image != null) ...[
            Expanded(
              flex: 2,
              child: LayoutBuilder(builder: (context, constraints) {
                double chosenSize = constraints.maxHeight > constraints.maxWidth
                    ? constraints.maxHeight
                    : constraints.maxHeight;
                return Center(
                  child: SizedBox(
                    height: chosenSize,
                    width: chosenSize,
                    child: ClipRRect(
                      borderRadius: BorderRadius.circular(35),
                      child: ImageOrRive(
                        exercise.image!,
                        fit: BoxFit.contain,
                      ),
                    ),
                  ),
                );
              }),
            ),
          ],
          SizedBox(height: S.x(2)),
          Expanded(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.start,
              children: [
                const AutoSizeText("Listen carefully and choose the right answer",
                    style: TextStyle(
                        fontFamily: 'Poppins',
                        fontWeight: FontWeight.w400,
                        fontSize: 26,
                        color: Color(0xFF8E8B8B)),
                    textAlign: TextAlign.center),
                SizedBox(height: S.x(2)),
                if (exercise.image == null) const Spacer(),
                Container(
                  alignment: Alignment.topCenter,
                  child: Column(
                    mainAxisSize: MainAxisSize.max,
                    children: [
                      if (audioExerciseIsPlaying)
                        const SpinKitWave(
                          color: C.GENIUS_PRIMARY,
                          size: 70,
                        ),
                      if (!audioExerciseIsPlaying)
                        GeniusRoundedSquareButton(
                          size: 80,
                          radius: 1000,
                          onTap: () {
                            if (!globalSoundEnabled) return;
                            if (byteData.value == null) return;
                            if (!canReplay) {
                              SnackbarHelper.showWarning(context, "You can play only twice");
                              return;
                            }
                            playedAmountState.value++;
                            audioPlayerService.playFile(data: byteData.value!);
                          },
                          style: canReplay ? GeniusButtonStyle.dark : GeniusButtonStyle.greyLight,
                          child: loading
                              ? const SizedBox(
                                  height: 70,
                                  width: 70,
                                  child: CircularProgressIndicator(
                                    color: C.GENIUS_WHITE,
                                  ),
                                )
                              : !hasPlayed
                                  ? const Icon(Icons.play_arrow_rounded)
                                  : const Icon(Icons.replay),
                        )
                    ],
                  ),
                ),
              ],
            ),
          ),
          Expanded(
            flex: exercise.image == null ? 2 : 1,
            child: MultipleChoice(
              confirmText: '',
              isHorizontal: !(exercise.displayWords ?? true),
              displayWords: exercise.displayWords ?? false,
              shuffle: false,
              answerIsInOptions: true,
              lined: true,
              correctAnswer: exercise.concept,
              choices: exercise.choices,
              onFinishedExercise: finishedExercise,
              onConfirmedExercise: onConfirmedExercise,
            ),
          ),
        ],
      ),
    );
  }
}
---
Path: /lib/pages/exercises/exercise_widgets/mcq_exercice.dart

import 'package:flutter/material.dart';
import 'package:twins/models/api/lesson_request.dart';
import 'package:twins/models/mcq_exercise_model.dart';
import 'package:twins/pages/exercises/exercise_widgets/card_content.dart';
import 'package:twins/style/values.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
class MCQExercise extends HookConsumerWidget {
  const MCQExercise({
    required this.exercise,
    required this.onFinishedExercise,
    required this.onConfirmedExercise,
    Key? key,
  }) : super(key: key);
  final MCQExerciseData exercise;
  final Function(bool, {TranslatedConcept? selected}) onFinishedExercise;
  final Function(bool) onConfirmedExercise;
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Column(
      mainAxisSize: MainAxisSize.max,
      children: [
        Expanded(
          child: Padding(
            padding: EdgeInsets.all(S.x(5)),
            child: LayoutBuilder(
              builder: (context, constraints) => Center(
                child: SizedBox(
                  width: constraints.maxWidth,
                  height: constraints.maxWidth,
                  child: Center(
                    child: FrontCardContent(
                      concept: exercise.answer,
                    ),
                  ),
                ),
              ),
            ),
          ),
        ),
        SizedBox(height: S.x(8)),
      ],
    );
  }
}
---
Path: /lib/pages/exercises/exercise_widgets/multiple_choice.dart

import 'package:auto_size_text/auto_size_text.dart';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:twins/models/api/lesson_request.dart';
import 'package:twins/models/mcq_exercise_model.dart';
import 'package:twins/models/results/exercise_result.dart';
import 'package:twins/providers/tts_provider.dart';
import 'package:twins/services/audio_player_service.dart';
import 'package:twins/style/genius_button_style.dart';
import 'package:twins/style/values.dart';
import 'package:twins/widgets/core/genius_button.dart';
import 'package:twins/widgets/core/genius_rounded_square_button.dart';
import 'package:google_fonts/google_fonts.dart';
class MultipleChoice extends HookConsumerWidget {
  const MultipleChoice({
    required this.correctAnswer,
    required this.choices,
    required this.onFinishedExercise,
    required this.onConfirmedExercise,
    this.onSelected,
    this.lined = false,
    this.shuffle = true,
    this.answerIsInOptions = false,
    this.displayWords = true,
    this.isHorizontal = false,
    this.confirmText,
    this.nextText,
    this.maxChoices = 4,
  });
  final TranslatedConcept correctAnswer;
  final List<TranslatedConcept> choices;
  final Function(ExerciseResult? result) onFinishedExercise;
  final Function(TranslatedConcept? concept)? onSelected;
  final Function(bool) onConfirmedExercise;
  final bool shuffle;
  final bool answerIsInOptions;
  final bool displayWords;
  final bool lined;
  final bool isHorizontal;
  final int maxChoices;
  final String? confirmText, nextText;
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final exercise = useMemoized(() {
      return MCQExerciseData.createMCQExerciseData(
        nbOptions: maxChoices,
        correctAnswer: correctAnswer,
        options: choices,
        shuffle: shuffle,
        answerIsInOptions: answerIsInOptions,
      );
    }, [correctAnswer, choices]);
    final generatedChoices = exercise.concepts;
    final selectedAnswerIndexState = useState<int?>(null);
    final selectedAnswerIndex = selectedAnswerIndexState.value;
    final isGoodAnswer =
        selectedAnswerIndex != null && generatedChoices[selectedAnswerIndex] == correctAnswer;
    final confirmedState = useState(false);
    final confirmed = confirmedState.value;
    final tts = ref.watch(ttsNotifierProvider(AudioPlayerType.EXERCISE).notifier);
    void playAudio(String text) async {
      String characterId = 'currentCharacterId';
      await tts.playAudio(text, characterId);
    }
    Widget content;
    if (!lined) {
      content = SizedBox(
        width: MediaQuery.of(context).size.width / 3,
        child: GridView.builder(
          padding: const EdgeInsets.all(20),
          physics: const NeverScrollableScrollPhysics(),
          gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
            crossAxisCount: 2,
            crossAxisSpacing: 20,
            mainAxisSpacing: S.x(2),
            childAspectRatio: 4,
          ),
          itemCount: generatedChoices.length,
          itemBuilder: (context, i) {
            return GeniusButton(
              expanded: false,
              radius: 65,
              style: selectedAnswerIndex == i && confirmed && !isGoodAnswer
                  ? GeniusButtonStyle.error
                  : confirmed && generatedChoices[i] == correctAnswer
                      ? GeniusButtonStyle.success
                      : selectedAnswerIndex == i
                          ? GeniusButtonStyle.dark
                          : GeniusButtonStyle.greyLight,
              onPressed: () {
                if (!confirmed) {
                  onSelected?.call(generatedChoices[i]);
                  selectedAnswerIndexState.value = i;
                  playAudio(generatedChoices[i].content);
                }
              },
              child: Center(child: AutoSizeText(generatedChoices[i].content)),
            );
          },
        ),
      );
    } else {
      if (!isHorizontal) {
        content = SizedBox(
          width: MediaQuery.of(context).size.width / 3,
          child: ListView.separated(
            shrinkWrap: true,
            physics: const NeverScrollableScrollPhysics(),
            separatorBuilder: (context, index) => const SizedBox(
              height: 10,
            ),
            itemCount: generatedChoices.length,
            itemBuilder: (context, i) {
              return GeniusButton(
                padding: const EdgeInsets.symmetric(horizontal: S.x4, vertical: S.x1),
                expanded: true,
                style: selectedAnswerIndex == i && confirmed && !isGoodAnswer
                    ? GeniusButtonStyle.error
                    : confirmed && generatedChoices[i] == correctAnswer
                        ? GeniusButtonStyle.success
                        : selectedAnswerIndex == i
                            ? GeniusButtonStyle.dark
                            : GeniusButtonStyle.greyLight,
                onPressed: () {
                  if (!confirmed) {
                    onSelected?.call(generatedChoices[i]);
                    selectedAnswerIndexState.value = i;
                    playAudio(generatedChoices[i].content);
                  }
                },
                child: Row(
                  children: [
                    Text((i + 1).toString(),
                        style: GoogleFonts.openSans(
                            fontWeight: FontWeight.w600,
                            fontSize: 25,
                            color: const Color(0xFFE2D9D9))),
                    const Spacer(),
                    AutoSizeText(generatedChoices[i].content),
                    const Spacer(),
                  ],
                ),
              );
            },
          ),
        );
      } else {
        content = Container(
          margin: const EdgeInsets.only(bottom: 20),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              for (final (i, _) in generatedChoices.indexed)
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 50),
                  child: GeniusRoundedSquareButton(
                    size: 80,
                    radius: 1000,
                    style: selectedAnswerIndex == i && confirmed && !isGoodAnswer
                        ? GeniusButtonStyle.error
                        : confirmed && generatedChoices[i] == correctAnswer
                            ? GeniusButtonStyle.success
                            : selectedAnswerIndex == i
                                ? GeniusButtonStyle.dark
                                : GeniusButtonStyle.greyLight,
                    onTap: () {
                      if (!confirmed) {
                        onSelected?.call(generatedChoices[i]);
                        selectedAnswerIndexState.value = i;
                        playAudio(generatedChoices[i].content);
                      }
                    },
                    child: AutoSizeText('${(i + 1)}',
                        style: const TextStyle(
                            fontFamily: 'OpenSans',
                            fontSize: 20,
                            fontWeight: FontWeight.w400,
                            color: Color(0xFF6F6666))),
                  ),
                ),
            ],
          ),
        );
      }
    }
    return Column(
      children: [
        Expanded(
            child: Padding(
          padding: const EdgeInsets.all(10.0),
          child: content,
        )),
        if (!confirmed)
          SizedBox(
            width: 420,
            child: GeniusButton(
              expanded: true,
              padding: EdgeInsets.symmetric(vertical: S.x3, horizontal: S.x(20)),
              style:
                  selectedAnswerIndex != null ? GeniusButtonStyle.dark : GeniusButtonStyle.disable,
              onPressed: () {
                if (selectedAnswerIndex == null) return;
                confirmedState.value = true;
                onConfirmedExercise(isGoodAnswer);
              },
              child: Text(confirmText ?? "Next"),
            ),
          ),
        if (confirmed)
          SizedBox(
            width: 420,
            child: GeniusButton(
              expanded: true,
              padding: EdgeInsets.symmetric(vertical: S.x3, horizontal: S.x(20)),
              style: GeniusButtonStyle.dark,
              onPressed: () {
                selectedAnswerIndexState.value = null;
                confirmedState.value = false;
                onFinishedExercise(
                  ExerciseResult(
                    exerciseId: exercise.answer.id,
                    success: isGoodAnswer,
                    userInput: generatedChoices[selectedAnswerIndex!],
                    correctAnswer: correctAnswer,
                  ),
                );
              },
              child: Text(nextText ?? "Next"),
            ),
          ),
      ],
    );
  }
}
---
Path: /lib/pages/exercises/exercise_widgets/reading_widget.dart

import 'package:auto_size_text/auto_size_text.dart';
import 'package:flutter/material.dart';
import 'package:twins/components/static_decoration.dart';
import 'package:twins/models/api/exercise_request.dart';
import 'package:twins/models/results/exercise_result.dart';
import 'package:twins/pages/exercises/exercise_widgets/multiple_choice.dart';
import 'package:twins/style/values.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
class ReadingWidget extends HookConsumerWidget {
  const ReadingWidget({
    required this.exercise,
    required this.onFinishedExercise,
    required this.onConfirmedExercise,
    Key? key,
  }) : super(key: key);
  final ReadingData exercise;
  final Function(List<ExerciseResult?> result) onFinishedExercise;
  final Function(bool) onConfirmedExercise;
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final ScrollController scrollController = ScrollController();
    void finishedExercise(ExerciseResult? result) {
      onFinishedExercise([result]);
    }
    return Padding(
      padding: EdgeInsets.symmetric(horizontal: S.x(18.5)),
      child: Column(
        mainAxisSize: MainAxisSize.max,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          AutoSizeText('',
              style: Theme.of(context)
                  .textTheme
                  .titleLarge
                  ?.copyWith(fontSize: 22, color: C.GENIUS_GREY_DARK)),
          height20,
          Expanded(
            flex: 2,
            child: Container(
              padding: const EdgeInsets.all(10),
              decoration: BoxDecoration(
                borderRadius: BorderRadius.circular(25.0),
                border: Border.all(color: const Color(0xFFDDDBDB), width: 1.5),
              ),
              child: RawScrollbar(
                thumbVisibility: true,
                controller: scrollController,
                child: SingleChildScrollView(
                  controller: scrollController,
                  child: Text(exercise.text),
                ),
              ),
            ),
          ),
          height15,
          AutoSizeText('Where will the concert be on July 21?',
              style: GoogleFonts.openSans(
                  fontWeight: FontWeight.w600, fontSize: 18, color: C.GENIUS_GREY_DARK)),
          height20,
          Expanded(
            flex: 4,
            child: Center(
              child: MultipleChoice(
                lined: true,
                correctAnswer: exercise.concept,
                choices: exercise.choices,
                onFinishedExercise: finishedExercise,
                onConfirmedExercise: onConfirmedExercise,
                confirmText: '',
              ),
            ),
          ),
        ],
      ),
    );
  }
}
---
Path: /lib/pages/exercises/exercise_widgets/scripted_conversation_widget.dart

import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:twins/models/api/chat_request.dart';
import 'package:twins/models/api/exercise_request.dart';
import 'package:twins/models/api/lesson_request.dart';
import 'package:twins/models/results/exercise_result.dart';
import 'package:twins/pages/exercises/conversation.dart';
import 'package:twins/pages/exercises/exercise_widgets/multiple_choice.dart';
import 'package:twins/providers/tts_provider.dart';
import 'package:twins/services/audio_player_service.dart';
import 'package:twins/style/genius_button_style.dart';
import 'package:twins/style/values.dart';
import 'package:twins/widgets/core/genius_button.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
class ScriptedConversationWidget extends HookConsumerWidget {
  const ScriptedConversationWidget({
    required this.exercise,
    required this.onFinishedExercise,
    required this.onConfirmedExercise,
    Key? key,
  }) : super(key: key);
  final ScriptedConversationData exercise;
  final Function(List<ExerciseResult?> result) onFinishedExercise;
  final Function(bool) onConfirmedExercise;
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final currentIndexState = useState(0);
    final currentIndex = currentIndexState.value;
    final ChatExchangeData? currentPractice =
        currentIndex >= exercise.conversation.length ? null : exercise.conversation[currentIndex];
    final messagesState = useState(<ChatExchange>[]);
    final messages = messagesState.value;
    final isTypingState = useState(true);
    final isTyping = isTypingState.value;
    final userEdit = currentIndex >= exercise.conversation.length
        ? false
        : exercise.conversation[currentIndex].type == ChatExchangeDataType.INPUT;
    final tts = ref.watch(ttsNotifierProvider(AudioPlayerType.INTERLOCUTOR).notifier);
    final isEnded = currentIndex >= exercise.conversation.length;
    final exerciseResultsState = useState<List<ExerciseResult>>([]);
    final exerciseResults = exerciseResultsState.value;
    void playAudio(String text) async {
      String characterId = 'currentCharacterId';
      await tts.playAudio(text, characterId);
    }
    List<ChatExchange> addMessages(List<ChatExchange> messages, [bool fromResponse = false]) {
      if (fromResponse) {
        final assistantReply =
            messages.lastWhere((element) => element.role == ChatSenderType.assistant);
        playAudio(assistantReply.concept.content);
      }
      final newArray = [
        ...messagesState.value,
        ...messages,
      ];
      messagesState.value = newArray;
      return newArray;
    }
    useEffect(() {
      if (currentIndex >= exercise.conversation.length || currentPractice == null) {
        return;
      }
      bool isInput = currentPractice.type == ChatExchangeDataType.INPUT;
      if (isInput) {
        return;
      }
      bool isAssistant = currentPractice.type == ChatExchangeDataType.ASSISTANT;
      bool isTranslated = false;
      WidgetsBinding.instance.addPostFrameCallback((_) async {
        isTypingState.value = true;
        await Future.delayed(const Duration(milliseconds: 800));
        if (currentIndex + 1 < exercise.conversation.length &&
            exercise.conversation[currentIndex + 1].type == ChatExchangeDataType.INPUT) {
          currentIndexState.value++;
        }
        isTypingState.value = false;
        addMessages([
          ChatExchange(
            concept: TranslatedConcept(
              content: currentPractice.concept.content,
              translation: currentPractice.concept.translation,
            ),
            displayTranslation: isTranslated,
            role: isAssistant ? ChatSenderType.assistant : ChatSenderType.user,
            type: isInput ? ChatMessageType.error : ChatMessageType.message,
          )
        ], isAssistant);
      });
      return null;
    }, [currentIndex]);
    void finishedExercise(ExerciseResult? result) {
      if (result != null) {
        addMessages([
          ChatExchange(
            concept: result.userInput!,
            role: ChatSenderType.user,
            type: ChatMessageType.message,
          ),
          if (!result.success)
            ChatExchange(
              concept: exercise.conversation[currentIndex].concept,
              role: ChatSenderType.user,
              type: ChatMessageType.error,
            ),
        ]);
        exerciseResultsState.value = [
          ...exerciseResultsState.value,
          ExerciseResult(
            exerciseId: exercise.conversation[currentIndex].id,
            success: result.success,
            correctAnswer: exercise.conversation[currentIndex].concept,
            userInput: result.userInput,
          )
        ];
      }
      currentIndexState.value++;
    }
    final currentExercise =
        currentIndex < exercise.conversation.length ? exercise.conversation[currentIndex] : null;
    return Column(
      mainAxisSize: MainAxisSize.max,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Expanded(
          child: Conversation(
            messages: messages,
            isTyping: isTyping,
          ),
        ),
        Padding(
          padding: const EdgeInsets.symmetric(horizontal: S.x5),
          child: Column(
            children: [
              if (!isEnded)
                Column(
                  children: [
                    Center(
                      child: AnimatedCrossFade(
                        firstChild: SizedBox(
                          height: MediaQuery.of(context).size.height / 3,
                          child: MultipleChoice(
                            confirmText: '',
                            maxChoices: 3,
                            shuffle: true,
                            lined: true,
                            correctAnswer: currentExercise!.concept,
                            choices: currentExercise.choices,
                            onFinishedExercise: finishedExercise,
                            onConfirmedExercise: onConfirmedExercise,
                          ),
                        ),
                        secondChild: SizedBox(
                          height: MediaQuery.of(context).size.height / 4,
                          width: double.infinity,
                        ),
                        crossFadeState:
                            userEdit ? CrossFadeState.showFirst : CrossFadeState.showSecond,
                        duration: const Duration(milliseconds: 0),
                      ),
                    ),
                  ],
                ),
              if (isEnded)
                GeniusButton(
                  expanded: true,
                  style: GeniusButtonStyle.dark,
                  onPressed: () {
                    onFinishedExercise(exerciseResults);
                  },
                  child: const Text('Finish conversation'),
                ),
              const SizedBox(
                height: S.x2,
              ),
            ],
          ),
        ),
      ],
    );
  }
}
---
Path: /lib/pages/exercises/exercise_widgets/vocabulary_acquisition_widget.dart

import 'package:auto_size_text/auto_size_text.dart';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:twins/components/static_decoration.dart';
import 'package:twins/models/api/exercise_request.dart';
import 'package:twins/models/results/exercise_result.dart';
import 'package:twins/pages/exercises/exercise_widgets/card_content.dart';
import 'package:twins/providers/tts_provider.dart';
import 'package:twins/services/audio_player_service.dart';
import 'package:twins/style/genius_button_style.dart';
import 'package:twins/style/values.dart';
import 'package:twins/widgets/core/flippable_widget.dart';
import 'package:twins/widgets/core/genius_button.dart';
class VocabularyAcquisitionWidget extends HookConsumerWidget {
  const VocabularyAcquisitionWidget({
    Key? key,
    required this.exercise,
    required this.onFinishedExercise,
  }) : super(key: key);
  final VocabularyAcquisitionData exercise;
  final Function(List<ExerciseResult?> results) onFinishedExercise;
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final showFront = useState(true);
    final tts = ref.watch(ttsNotifierProvider(AudioPlayerType.EXERCISE).notifier);
    void playAudio(String text) async {
      String characterId = 'currentCharacterId';
      await tts.playAudio(text, characterId);
    }
    return Padding(
      padding: EdgeInsets.symmetric(horizontal: S.x(18.5)),
      child: Column(
        mainAxisSize: MainAxisSize.max,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          AutoSizeText('Lets learn some words!',
              style: Theme.of(context)
                  .textTheme
                  .titleLarge
                  ?.copyWith(fontSize: 25, fontWeight: FontWeight.w700, color: C.GENIUS_BLACK)),
          customHeight(20),
          Expanded(
            child: LayoutBuilder(
              builder: (context, constraints) => Center(
                child: SizedBox(
                  width: constraints.maxHeight,
                  height: constraints.maxHeight,
                  child: FlippableWidget(
                    showFront: showFront.value,
                    frontContent: FrontCardContent(
                      concept: exercise.concept,
                      onTap: () {
                        playAudio(exercise.concept.content);
                        showFront.value = !showFront.value;
                      },
                    ),
                    backContent: BackCardContent(
                      concept: exercise.concept,
                      onTap: () => showFront.value = !showFront.value,
                    ),
                  ),
                ),
              ),
            ),
          ),
          customHeight(40),
          Center(
            child: GeniusButton(
              style: GeniusButtonStyle.dark,
              onPressed: () {
                onFinishedExercise([null]);
              },
              padding: const EdgeInsets.symmetric(vertical: S.x2, horizontal: 100),
              child: const AutoSizeText("Next"),
            ),
          ),
        ],
      ),
    );
  }
}
---
Path: /lib/pages/exercises/exercise_widgets/vocabulary_dialog.dart

import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:twins/mixins/widget.dart';
import 'package:twins/models/api/lesson_request.dart';
import 'package:twins/style/values.dart';
class VocabularyDialog extends HookWidget with DialogWidget {
  final List<TranslatedConcept> notUsedConcepts;
  final List<TranslatedConcept> usedConcepts;
  VocabularyDialog({
    required this.notUsedConcepts,
    required this.usedConcepts,
  });
  @override
  Widget build(BuildContext context) {
    return SizedBox(
      height: 300,
      child: Column(
        children: [
          Stack(
            children: [
              Align(
                alignment: Alignment.center,
                child: Padding(
                  padding: const EdgeInsets.only(top: S.x3),
                  child: Text("Vocabulary".toUpperCase(),
                      style: Theme.of(context).textTheme.titleMedium),
                ),
              ),
              Align(
                alignment: Alignment.centerRight,
                child: IconButton(
                  icon: Icon(Icons.close_sharp, color: Colors.grey.shade600, size: 40),
                  onPressed: () => dismiss(),
                ),
              ),
            ],
          ),
          Expanded(
            child: SingleChildScrollView(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  for (var concept in notUsedConcepts)
                    ListTile(
                      title: Text(concept.translation ?? concept.content),
                    ),
                  for (var concept in usedConcepts)
                    ListTile(
                      title: Text(
                        concept.translation ?? concept.content,
                        style: TextStyle(
                          color: Colors.grey.shade600,
                          decoration: TextDecoration.lineThrough,
                        ),
                      ),
                    ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
}
---
Path: /lib/pages/exercises/exercise_widgets/vocabulary_practice_widget.dart

import 'package:auto_size_text/auto_size_text.dart';
import 'package:flutter/material.dart';
import 'package:twins/components/static_decoration.dart';
import 'package:twins/models/api/exercise_request.dart';
import 'package:twins/models/results/exercise_result.dart';
import 'package:twins/pages/exercises/exercise_widgets/card_content.dart';
import 'package:twins/pages/exercises/exercise_widgets/multiple_choice.dart';
import 'package:twins/style/values.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
class VocabularyPracticeWidget extends HookConsumerWidget {
  const VocabularyPracticeWidget({
    required this.exercise,
    required this.onFinishedExercise,
    required this.onConfirmedExercise,
    Key? key,
  }) : super(key: key);
  final VocabularyPracticeData exercise;
  final Function(List<ExerciseResult?> results) onFinishedExercise;
  final Function(bool) onConfirmedExercise;
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    void finishedExercise(ExerciseResult? result) {
      onFinishedExercise([result]);
    }
    return Padding(
      padding: EdgeInsets.symmetric(horizontal: S.x(18.5)),
      child: Column(
        mainAxisSize: MainAxisSize.max,
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          Align(
            alignment: AlignmentDirectional.topStart,
            child: AutoSizeText('Let\'s learn some words!',
                style: Theme.of(context)
                    .textTheme
                    .titleLarge
                    ?.copyWith(fontSize: 25, fontWeight: FontWeight.w700, color: C.GENIUS_BLACK)),
          ),
          customHeight(20),
          Expanded(
            flex: 3,
            child: LayoutBuilder(
              builder: (context, constraints) => Center(
                child: SizedBox(
                  width: constraints.maxHeight,
                  height: constraints.maxHeight,
                  child: FrontCardContent(
                    concept: exercise.concept,
                  ),
                ),
              ),
            ),
          ),
          SizedBox(height: S.x(2)),
          Expanded(
            flex: 2,
            child: MultipleChoice(
              correctAnswer: exercise.concept,
              choices: exercise.choices,
              onFinishedExercise: finishedExercise,
              onConfirmedExercise: onConfirmedExercise,
            ),
          ),
          height20
        ],
      ),
    );
  }
}
---
Path: /lib/pages/exercises/exercise_widgets/word_completion_widget.dart

import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:twins/components/static_decoration.dart';
import 'package:twins/models/api/exercise_request.dart';
import 'package:twins/models/api/lesson_request.dart';
import 'package:twins/models/results/exercise_result.dart';
import 'package:twins/pages/exercises/exercise_widgets/multiple_choice.dart';
import 'package:twins/style/values.dart';
import 'package:twins/utilities/custom_split.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
class WordCompletionWidget extends HookConsumerWidget {
  const WordCompletionWidget({
    required this.exercise,
    required this.onFinishedExercise,
    required this.onConfirmedExercise,
    Key? key,
  }) : super(key: key);
  final WordCompletionData exercise;
  final Function(List<ExerciseResult?> result) onFinishedExercise;
  final Function(bool) onConfirmedExercise;
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final elementsState = useState<List<WordElement>>([]);
    final elements = elementsState.value;
    void finishedExercise(ExerciseResult? result) {
      onFinishedExercise([result]);
    }
    useEffect(() {
      List<String> parts = customSplit(exercise.sentence);
      WidgetsBinding.instance.addPostFrameCallback((_) {
        elementsState.value = parts.map((e) {
          if (e == '\$w') {
            return WordElement(TranslatedConcept(content: e), WordElementType.EMPTY);
          } else {
            return WordElement(TranslatedConcept(content: e), WordElementType.STATIC);
          }
        }).toList();
      });
      return null;
    }, []);
    return Padding(
      padding: EdgeInsets.symmetric(horizontal: S.x(18.5)),
      child: Column(
        mainAxisSize: MainAxisSize.max,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text('',
              style: Theme.of(context)
                  .textTheme
                  .titleLarge
                  ?.copyWith(fontSize: 40, fontWeight: FontWeight.w700, color: C.GENIUS_BLACK)),
          height20,
          Expanded(
            child: Center(
              child: Text.rich(
                TextSpan(
                  style: const TextStyle(
                      fontSize: 22, fontWeight: FontWeight.w400, color: Color(0xFF565656)),
                  children: [
                    for (final e in elements) ...[
                      if (e.type == WordElementType.STATIC) TextSpan(text: e.concept.content),
                      if (e.type == WordElementType.EMPTY)
                        WidgetSpan(
                          child: Container(
                            margin: const EdgeInsets.only(top: 22),
                            width: 60,
                            height: 2,
                            child: const Divider(color: C.GENIUS_GREY),
                          ),
                        ),
                      if (e.type == WordElementType.FILLED)
                        WidgetSpan(
                          child: Container(
                            padding: const EdgeInsets.fromLTRB(5, 0, 5, 0),
                            decoration: const BoxDecoration(
                              border: Border(
                                bottom: BorderSide(
                                  color: C.GENIUS_GREY,
                                  width: 1.0, 
                                ),
                              ),
                            ),
                            child: Text(
                              e.concept.content,
                              style: const TextStyle(
                                  fontSize: 22,
                                  fontWeight: FontWeight.w400,
                                  color: C.GENIUS_PRIMARY),
                            ),
                          ),
                        ),
                    ]
                  ],
                ),
              ),
            ),
          ),
          Expanded(
            flex: 2,
            child: Center(
              child: MultipleChoice(
                lined: true,
                confirmText: '',
                correctAnswer: exercise.concept,
                choices: exercise.choices,
                onFinishedExercise: finishedExercise,
                onConfirmedExercise: onConfirmedExercise,
                onSelected: (concept) {
                  if (concept == null) return;
                  elementsState.value = [
                    ...elementsState.value.map((e) {
                      if (e.type == WordElementType.EMPTY || e.type == WordElementType.FILLED) {
                        return WordElement(concept, WordElementType.FILLED);
                      } else {
                        return e;
                      }
                    }).toList()
                  ];
                },
              ),
            ),
          ),
        ],
      ),
    );
  }
}
---
Path: /lib/pages/exercises/exercise_widgets/word_reordering_widget.dart

import 'package:auto_size_text/auto_size_text.dart';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:twins/components/static_decoration.dart';
import 'package:twins/models/api/exercise_request.dart';
import 'package:twins/models/api/lesson_request.dart';
import 'package:twins/models/results/exercise_result.dart';
import 'package:twins/providers/tts_provider.dart';
import 'package:twins/services/audio_player_service.dart';
import 'package:twins/style/genius_button_style.dart';
import 'package:twins/style/values.dart';
import 'package:twins/utilities/custom_split.dart';
import 'package:twins/widgets/core/genius_button.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
class WordReorderingWidget extends HookConsumerWidget {
  const WordReorderingWidget({
    required this.exercise,
    required this.onFinishedExercise,
    required this.onConfirmedExercise,
    Key? key,
  }) : super(key: key);
  final WordReorderingData exercise;
  final Function(List<ExerciseResult?> result) onFinishedExercise;
  final Function(bool) onConfirmedExercise;
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final elemetsState = useState<List<WordElement>>([]);
    final elements = elemetsState.value;
    final choicesState = useState<List<TranslatedConcept>>(exercise.choices);
    final choices = choicesState.value;
    final hasConfirmedState = useState(false);
    final hasConfirmed = hasConfirmedState.value;
    final canConfirm = elements.where((element) => element.type == WordElementType.EMPTY).isEmpty;
    final tts = ref.watch(ttsNotifierProvider(AudioPlayerType.EXERCISE).notifier);
    void checkConfirm() {
      if (canConfirm) {
        String result = elements.map((e) => e.concept.content).join();
        bool success = result == exercise.goodSentence;
        onConfirmedExercise(success);
        tts.playAudio(exercise.goodSentence, 'currentCharacterId');
        hasConfirmedState.value = true;
      }
    }
    void finishedExercise(ExerciseResult? result) {
      onFinishedExercise([result]);
    }
    void finishExercise() {
      String res = elements.map((e) => e.concept.content).join();
      finishedExercise(
        ExerciseResult(
          success: res == exercise.goodSentence,
          correctAnswer: TranslatedConcept(content: exercise.goodSentence),
          userInput: TranslatedConcept(content: res),
          exerciseId: TranslatedConcept(content: res).id,
        ),
      );
    }
    useEffect(() {
      List<String> parts = customSplit(exercise.sentence);
      WidgetsBinding.instance.addPostFrameCallback((_) {
        elemetsState.value = parts.map((e) {
          if (e == '\$w') {
            return WordElement(TranslatedConcept(content: e), WordElementType.EMPTY);
          } else {
            return WordElement(TranslatedConcept(content: e), WordElementType.STATIC);
          }
        }).toList();
      });
      return null;
    }, []);
    void playAudio(String text) async {
      String characterId = 'currentCharacterId';
      await tts.playAudio(text, characterId);
    }
    return Padding(
      padding: EdgeInsets.symmetric(horizontal: S.x(18.5)),
      child: Column(
        mainAxisSize: MainAxisSize.max,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text('',
              style: Theme.of(context)
                  .textTheme
                  .titleLarge
                  ?.copyWith(fontSize: 25, fontWeight: FontWeight.w700, color: C.GENIUS_BLACK)),
          customHeight(50),
          customHeight(20),
          Expanded(
            flex: 2,
            child: Text.rich(
              TextSpan(
                children: [
                  for (final e in elements) ...[
                    if (e.type == WordElementType.STATIC)
                      TextSpan(
                          text: e.concept.content,
                          style: const TextStyle(
                              fontFamily: 'Poppins',
                              fontSize: 22,
                              fontWeight: FontWeight.w400,
                              color: Color(0xFF565656))),
                    if (e.type == WordElementType.EMPTY)
                      WidgetSpan(
                        alignment: PlaceholderAlignment.middle,
                        child: Container(
                          margin: const EdgeInsets.only(top: 5),
                          width: S.x(40),
                          height: S.x(10),
                          padding: const EdgeInsets.symmetric(horizontal: 20),
                          child: const Card(
                            color: Color(0xFFF9FAFC),
                          ),
                        ),
                      ),
                    if (e.type == WordElementType.FILLED)
                      WidgetSpan(
                        alignment: PlaceholderAlignment.middle,
                        child: Container(
                          margin: const EdgeInsets.only(top: 5),
                          width: S.x(40),
                          height: S.x(10),
                          padding: const EdgeInsets.symmetric(horizontal: 20),
                          child: GeniusButton(
                              expanded: true,
                              style: GeniusButtonStyle.greyLight,
                              onPressed: () {
                                bool replaced = false;
                                elemetsState.value = [
                                  ...elemetsState.value.map((el) {
                                    if (!replaced &&
                                        e.type == WordElementType.FILLED &&
                                        e.concept == el.concept) {
                                      replaced = true;
                                      return WordElement(e.concept, WordElementType.EMPTY);
                                    } else {
                                      return el;
                                    }
                                  }).toList()
                                ];
                                choicesState.value = [...choices, e.concept];
                              },
                              child: AutoSizeText(e.concept.content,
                                  style: const TextStyle(
                                      fontFamily: 'Poppins',
                                      fontSize: 33,
                                      fontWeight: FontWeight.w400,
                                      color: Color(0xFF565656)))),
                        ),
                      )
                  ]
                ],
              ),
            ),
          ),
          Expanded(
            flex: 1,
            child: Row(
              children: [
                for (final c in choices) ...[
                  Container(
                    width: S.x(40),
                    height: S.x(12),
                    padding: const EdgeInsets.symmetric(horizontal: 20),
                    child: GeniusButton(
                      expanded: true,
                      style: GeniusButtonStyle.greyLight,
                      onPressed: () {
                        playAudio(c.content);
                        choicesState.value = [
                          ...choicesState.value.where((element) => element != c)
                        ];
                        bool replaced = false;
                        elemetsState.value = [
                          ...elemetsState.value.map((e) {
                            if (e.type == WordElementType.EMPTY && !replaced) {
                              replaced = true;
                              return WordElement(c, WordElementType.FILLED);
                            } else {
                              return e;
                            }
                          }).toList()
                        ];
                      },
                      child: AutoSizeText(c.content),
                    ),
                  )
                ]
              ],
            ),
          ),
          const Spacer(),
          if ( !hasConfirmed)
            Center(
              child: GeniusButton(
                style: canConfirm ? GeniusButtonStyle.dark : GeniusButtonStyle.disable,
                onPressed: () {
                  if (!canConfirm) return;
                  checkConfirm();
                },
                padding: const EdgeInsets.symmetric(vertical: S.x2, horizontal: 100),
                child: const AutoSizeText(""),
              ),
            ),
          if (hasConfirmed)
            Center(
              child: GeniusButton(
                style: GeniusButtonStyle.dark,
                onPressed: () {
                  finishExercise();
                },
                padding: const EdgeInsets.symmetric(vertical: S.x2, horizontal: 100),
                child: const AutoSizeText("Next"),
              ),
            ),
          height20,
        ],
      ),
    );
  }
}
---
Path: /lib/providers/asset_or_network_file_provider.dart

import 'dart:convert';
import 'dart:io';
import 'package:crypto/crypto.dart';
import 'package:dio/dio.dart';
import 'package:twins/models/api/section_request.dart';
import 'package:path_provider/path_provider.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:flutter/services.dart';
import 'dio_client_provider.dart';
part 'asset_or_network_file_provider.g.dart';
Future<ByteData?> getAssetOrNetworkFile(Dio dio, String uri) async {
  final isRemote = uri.startsWith('http');
  String filePath = uri;
  if (!isRemote) {
    try {
      return await rootBundle.load(uri);
    } catch (e) {
      return null;
    }
  }
  final tempDir = await getTemporaryDirectory();
  filePath = '${tempDir.path}/${md5.convert(utf8.encode(uri)).toString()}';
  final file = File(filePath);
  if (await file.exists()) {
    try {
      return file.readAsBytesSync().buffer.asByteData();
    } catch (e) {
      return null;
    }
  } else {
    try {
      final res = await dio.get(
        uri,
        options: Options(responseType: ResponseType.bytes),
      );
      await file.writeAsBytes(res.data);
      return file.readAsBytesSync().buffer.asByteData();
    } catch (e) {
      return null;
    }
  }
}
@riverpod
Future<ByteData?> assetOrNetworkFile(AssetOrNetworkFileRef ref, String uri) async {
  final dio = ref.watch(dioClientProvider);
  return getAssetOrNetworkFile(dio, uri);
}
@riverpod
Future<List<ByteData?>> preloadSection(PreloadSectionRef ref, SectionData section) async {
  final dio = ref.watch(dioClientProvider);
  final uniqUris = section.neededFiles.toSet().toList();
  final byteDataList = await Future.wait(uniqUris.map((uri) async {
    return getAssetOrNetworkFile(dio, uri);
  }));
  return byteDataList;
}
---
Path: /lib/providers/dio_client_provider.dart

import 'package:dio/dio.dart';
import 'package:flutter/foundation.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:twins/components/app_asset.dart';
part 'dio_client_provider.g.dart';
@riverpod
Dio dioClient(DioClientRef ref) {
  final dio = Dio();
  final String apiUrl = AppConstants.apiUrl;
  dio.options.baseUrl = apiUrl;
  dio.options.headers = {
    'Content-Type': 'application/json',
    'Accept': 'application/json',
    'learning-language': 'en',
    'user-language': 'ja',
  };
  dio.interceptors.addAll([
    InterceptorsWrapper(
      onRequest: (options, handler) async {
        final session = Supabase.instance.client.auth.currentSession;
        final token = session?.accessToken;
        if (token != null) {
          options.headers['Authorization'] = 'Bearer $token';
        } else {
          dio.options.headers.remove('Authorization');
        }
        debugPrint("Submitting to URL: ${options.baseUrl}${options.path}");
        debugPrint('Request: ${options.method} ${options.path}');
        debugPrint('Headers: ${options.headers}');
        debugPrint('Data: ${options.data}');
        return handler.next(options);
      },
      onResponse: (response, handler) {
        debugPrint('Response: ${response.statusCode}');
        debugPrint('Response Data: ${response.data}');
        return handler.next(response);
      },
      onError: (DioException e, handler) {
        debugPrint('Dio Error!');
        debugPrint('Error: ${e.error}');
        debugPrint('Response: ${e.response}');
        debugPrint('Message: ${e.message}');
        debugPrint('Request: ${e.requestOptions.method} ${e.requestOptions.path}');
        debugPrint('Request Data: ${e.requestOptions.data}');
        debugPrint('Response Data: ${e.response?.data}');
        return handler.next(e);
      },
    ),
  ]);
  return dio;
}
---
Path: /lib/providers/feedback_helper_provider.dart

import 'package:flutter/services.dart';
import 'package:twins/providers/setting_provider.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:twins/services/audio_player_service.dart';
part 'feedback_helper_provider.g.dart';
@riverpod
class FeedbackHelper extends _$FeedbackHelper {
  late bool _hapticEnabled, _sfxEnabled;
  late AudioPlayerService _audioPlayerService;
  @override
  FeedbackHelper build() {
    _audioPlayerService = ref.watch(audioPlayerServiceProvider(AudioPlayerType.FEEDBACK).notifier);
    _hapticEnabled = ref.watch(hapticEnabledProvider.select((value) => value));
    _sfxEnabled = ref.watch(sfxEnabledProvider.select((value) => value));
    return state;
  }
  Future<void> Success({hapticEnabled = true, sfxEnabled = true}) async {
    if (_hapticEnabled && hapticEnabled) {
      HapticFeedback.lightImpact();
    }
    if (_sfxEnabled && sfxEnabled) {
      String assetPath = 'assets/audios/SuccessExercises.mp3';
      _audioPlayerService.play(assetPath);
    }
  }
  Future<void> Failure() async {
    if (_hapticEnabled) {
      HapticFeedback.lightImpact();
    }
    if (_sfxEnabled) {
      String assetPath = 'assets/audios/FailureExercises.mp3';
      _audioPlayerService.play(assetPath);
    }
  }
  Future<void> Finish() async {
    if (_hapticEnabled) {
      HapticFeedback.lightImpact();
    }
    if (_sfxEnabled) {
      String assetPath = 'assets/audios/EndofLessonSuccess.mp3';
      _audioPlayerService.play(assetPath);
    }
  }
}
---
Path: /lib/providers/genius_api_provider.dart

import 'package:twins/providers/dio_client_provider.dart';
import 'package:twins/services/api/genius_api.dart';
import 'package:twins/services/repositories/genius_repository.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
part 'genius_api_provider.g.dart';
@riverpod
GeniusApi geniusApi(GeniusApiRef ref) {
  return GeniusApi(ref.read(dioClientProvider));
}
@riverpod
GeniusRepository geniusRepository(GeniusRepositoryRef ref) {
  return GeniusRepository(ref.read(geniusApiProvider));
}
---
Path: /lib/providers/genius_result_provider.dart

import 'package:collection/collection.dart';
import 'package:twins/features/profile/presentation/providers/profile_provider.dart';
import 'package:twins/models/api/lesson_request.dart';
import 'package:twins/models/api/module_request.dart';
import 'package:twins/models/api/section_request.dart';
import 'package:twins/models/results/lesson_result.dart';
import 'package:twins/models/results/level_result.dart';
import 'package:twins/models/results/module_result.dart';
import 'package:twins/models/results/section_result.dart';
import 'package:twins/services/genius_result_service.dart';
import 'package:twins/services/repositories/genius_result_repository.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:shared_preferences/shared_preferences.dart';
part 'genius_result_provider.g.dart';
@riverpod
Future<SharedPreferences> prefs(PrefsRef ref) async {
  return SharedPreferences.getInstance();
}
@riverpod
GeniusResultRepository? geniusResultRepository(GeniusResultRepositoryRef ref) {
  final prefs = ref.watch(prefsProvider);
  return prefs.maybeMap(
      orElse: () => null,
      data: (value) {
        return GeniusResultRepository(value.value);
      });
}
@riverpod
LevelResult? levelResult(
  LevelResultRef ref, {
  required String level,
}) {
  final result = ref.watch(geniusResultServiceProvider);
  if (result == null) return null;
  return result.levels[level];
}
@riverpod
ModuleResult? moduleResult(
  ModuleResultRef ref, {
  required String level,
  required String module,
}) {
  final result = ref.watch(levelResultProvider(level: level));
  if (result == null) return null;
  return result.modules[module];
}
@riverpod
List<SectionResult> sectionResultsByKey(
  SectionResultsByKeyRef ref, {
  required String level,
  required String key,
}) {
  final result = ref.watch(levelResultProvider(level: level));
  final List<SectionResult> sections = [];
  if (result == null) return [];
  for (final moduleResult in result.modules.keys) {
    final module = result.modules[moduleResult];
    if (module == null) continue;
    for (final lessonResult in module.lessons.keys) {
      final lesson = module.lessons[lessonResult];
      if (lesson == null) continue;
      for (final sectionResult in lesson.sections.keys) {
        if (sectionResult != key) continue;
        final section = lesson.sections[sectionResult];
        if (section == null) continue;
        sections.add(section);
      }
    }
  }
  return sections;
}
@riverpod
double vocabularyScore(
  VocabularyScoreRef ref, {
  required String level,
}) {
  final sections =
      ref.watch(sectionResultsByKeyProvider(level: level, key: SectionType.VOCABULARY.name));
  if (sections.isEmpty) return 0.0;
  final sum = sections.map((e) => e.score).reduce((a, b) => a + b);
  return sum / sections.length;
}
@riverpod
double listeningScore(
  ListeningScoreRef ref, {
  required String level,
}) {
  final sections =
      ref.watch(sectionResultsByKeyProvider(level: level, key: SectionType.LISTENING.name));
  if (sections.isEmpty) return 0.0;
  final sum = sections.map((e) => e.score).reduce((a, b) => a + b);
  return sum / sections.length;
}
@riverpod
LessonResult? lessonResult(
  LessonResultRef ref, {
  required String level,
  required String module,
  required String lesson,
}) {
  final result = ref.watch(moduleResultProvider(level: level, module: module));
  if (result == null) return null;
  return result.lessons[lesson];
}
@riverpod
SectionResult? sectionResult(
  SectionResultRef ref, {
  required String level,
  required String module,
  required String lesson,
  required String section,
}) {
  final result = ref.watch(lessonResultProvider(level: level, module: module, lesson: lesson));
  if (result == null) return null;
  return result.sections[section];
}
@riverpod
String? currentLevel(
  CurrentLevelRef ref,
) {
  return ref.watch(userProfileOrNullProvider)?.level;
}
@riverpod
double lessonProgress(
  LessonProgressRef ref, {
  required String level,
  required String module,
  required String lesson,
  required LessonData? lessonData,
}) {
  if (lessonData == null) return 0.0;
  final result = ref.watch(lessonResultProvider(level: level, module: module, lesson: lesson));
  if (result == null) return 0;
  return result.sections.length / lessonData.sections.length;
}
@riverpod
double moduleProgress(
  ModuleProgressRef ref, {
  required String level,
  required String module,
  required GeniusModule? moduleData,
}) {
  if (moduleData == null) return 0.0;
  final result = ref.watch(moduleResultProvider(level: level, module: module));
  if (result == null) return 0.0;
  double sum = result.lessons.keys.map((key) {
    return ref.read(
      lessonProgressProvider(
        level: level,
        module: module,
        lesson: key,
        lessonData: moduleData.lessons.firstWhere((element) => element.key == key),
      ),
    );
  }).reduce((a, b) => a + b);
  return sum / moduleData.lessons.length;
}
@riverpod
double levelProgress(
  LevelProgressRef ref, {
  required String level,
  required List<GeniusModule> modules,
}) {
  final result = ref.watch(levelResultProvider(level: level));
  if (result == null) return 0;
  double sum = result.modules.keys.map((key) {
    GeniusModule? module = modules.firstWhereOrNull((element) => element.key == key);
    return ref.read(
      moduleProgressProvider(
        level: level,
        module: key,
        moduleData: module,
      ),
    );
  }).reduce((a, b) => a + b);
  return modules.isNotEmpty ? sum / modules.length : 0;
}
@riverpod
GeniusModule? moduleToWorkOn(
  ModuleToWorkOnRef ref, {
  required String level,
  required List<GeniusModule> modules,
}) {
  GeniusModule? targetModule;
  if (modules.isEmpty) return null;
  for (var module in modules) {
    final moduleProgress = ref.read(moduleProgressProvider(
      level: level,
      module: module.key,
      moduleData: module,
    ));
    if (moduleProgress < 1.0) {
      targetModule = module;
      break;
    }
  }
  return targetModule ?? modules.first;
}
---
Path: /lib/providers/setting_provider.dart

import 'package:twins/notifiers/setting_notifier.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
part 'setting_provider.g.dart';
@riverpod
bool sfxEnabled(SfxEnabledRef ref) {
  final sfxEnabled = ref.watch(settingNotifierProvider.select((value) => value.sfxEnabled));
  return sfxEnabled;
}
@riverpod
bool hapticEnabled(HapticEnabledRef ref) {
  final hapticEnabled = ref.watch(settingNotifierProvider.select((value) => value.hapticEnabled));
  return hapticEnabled;
}
---
Path: /lib/providers/shared_preferences_provider.dart

import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:shared_preferences/shared_preferences.dart';
part 'shared_preferences_provider.g.dart';
@riverpod
Future<SharedPreferences> sharedPreferences(SharedPreferencesRef ref) async {
  return await SharedPreferences.getInstance();
}
@riverpod
SharedPreferences? sharedPreferencesOrNull(SharedPreferencesOrNullRef ref) {
  return ref.watch(sharedPreferencesProvider).whenOrNull(data: (value) => value);
}
---
Path: /lib/providers/speech_to_text_provider.dart

import 'package:twins/models/speech_to_text_model.dart';
import 'package:twins/services/speech_to_text_service.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
part 'speech_to_text_provider.g.dart';
@riverpod
bool speechToTextHasAccess(SpeechToTextHasAccessRef ref) {
  final hasAccess = ref.watch(speechToTextServiceProvider.select((value) => value.hasAccess));
  return hasAccess;
}
@riverpod
SpeechToTextStatus speechToTextStatus(SpeechToTextStatusRef ref) {
  final status = ref.watch(speechToTextServiceProvider.select((value) => value.status));
  return status;
}
@riverpod
bool speechToTextIsListening(SpeechToTextIsListeningRef ref) {
  final status = ref.watch(speechToTextStatusProvider);
  return status == SpeechToTextStatus.listening;
}
@riverpod
Stream<String> speechToTextListenStream(SpeechToTextListenStreamRef ref) {
  final speechToText = ref.watch(speechToTextServiceProvider.notifier);
  return speechToText.listen();
}
---
Path: /lib/providers/tts_provider.dart

import 'dart:io';
import 'package:path_provider/path_provider.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:twins/features/tts/domain/providers/tts_client_provider.dart';
import 'package:twins/services/audio_player_service.dart';
part 'tts_provider.g.dart';
@riverpod
class TtsNotifier extends _$TtsNotifier {
  late AudioPlayerService _audioPlayerService;
  @override
  AudioPlayerState build(AudioPlayerType type) {
    _audioPlayerService = ref.watch(audioPlayerServiceProvider(type).notifier);
    return ref.watch(audioPlayerServiceProvider(type));
  }
  String _buildFileName(String text, String characterId) {
    String hashedString = text + characterId;
    return '${hashedString.hashCode}.mp3'; 
  }
  Future<bool> audioExists(String text, String characterId) {
    String fileName = _buildFileName(text, characterId);
    return getTemporaryDirectory().then((tempDir) async {
      File file = File('${tempDir.path}/$fileName');
      return await file.exists();
    });
  }
  Future<void> playAudio(String text, String characterId) async {
    try {
      String fileName = _buildFileName(text, characterId);
      var tempDir = await getTemporaryDirectory();
      File file = File('${tempDir.path}/$fileName');
      if (!await file.exists()) {
        final getAudioFromTextUseCase = ref.read(getAudioFromTextUseCaseProvider);
        List<int>? bytes = await getAudioFromTextUseCase.call(text, characterId);
        if (bytes == null) {
          return;
        }
        await file.writeAsBytes(bytes);
      }
      final bytes = await file.readAsBytes();
      _audioPlayerService.playFile(data: bytes.buffer.asByteData(), fileName: fileName);
    } catch (e) {
      return;
    }
  }
  void stop() {
    _audioPlayerService.stop();
  }
}
---
Path: /lib/providers/exercise_result_repository_provider.dart

import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:twins/services/repositories/exercise_result_repository.dart';
import 'package:twins/providers/genius_api_provider.dart';
part 'exercise_result_repository_provider.g.dart';
@riverpod
ExerciseResultRepository exerciseResultRepository(ExerciseResultRepositoryRef ref) {
  final geniusRepository = ref.watch(geniusRepositoryProvider);
  return ExerciseResultRepository(geniusRepository);
}
---
Path: /lib/services/api_service.dart

import 'package:dio/dio.dart';
import 'package:flutter/foundation.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:logger/logger.dart';
import 'package:twins/models/api/chat_request.dart';
import 'package:twins/models/api/lesson_request.dart';
import 'package:twins/providers/dio_client_provider.dart';
import 'package:twins/utilities/logger.dart';
class ApiService extends ChangeNotifier {
  ApiService();
  CancelToken getLessonsToken = CancelToken();
  List<LessonData>? cachedLessons;
  ChatRequestState _chatRequestState = const ChatRequestState.initial();
  ChatRequestState get chatRequestState => _chatRequestState;
  CancelToken getTranslationToken = CancelToken();
  final Logger _logger = Logger(
    printer: createSimplePrefixPrinter(
      PrettyPrinter(methodCount: 3),
      prefix: '[API]',
    ),
  );
  Future<void> postChat(ChatRequestData data) async {
    try {
      _chatRequestState = const ChatRequestState.loading();
      notifyListeners();
      final dio = ProviderContainer().read(dioClientProvider);
      final response = await dio.post('/chat', data: data);
      _logger.i(response.data);
      _chatRequestState = ChatRequestState.success(ChatResponse.fromJson(response.data));
      notifyListeners();
    } on DioException catch (e) {
      _logger.e(e);
      _chatRequestState = const ChatRequestState.failure("Error");
      notifyListeners();
    }
    _chatRequestState = const ChatRequestState.initial();
  }
}
---
Path: /lib/services/audio_player_service.dart

import 'dart:io';
import 'package:audio_session/audio_session.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_sound/public/flutter_sound_player.dart';
import 'package:logger/logger.dart';
import 'package:path_provider/path_provider.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:twins/models/setting_model.dart';
import 'package:twins/notifiers/setting_notifier.dart';
part 'audio_player_service.g.dart';
enum AudioPlayerState {
  initial,
  stopped,
  playing,
  failed,
}
enum AudioPlayerType {
  FEEDBACK,
  EXERCISE,
  INTERLOCUTOR,
  BACKGROUND_MUSIC,
}
@riverpod
class AudioPlayerService extends _$AudioPlayerService {
  final FlutterSoundPlayer _audioPlayer = FlutterSoundPlayer(logLevel: Level.error);
  late Setting _setting;
  @override
  AudioPlayerState build(AudioPlayerType type) {
    _init();
    ref.onDispose(() {
      Future.delayed(
        const Duration(seconds: 5),
        () {
          _audioPlayer.closePlayer();
        },
      );
    });
    _setting = ref.watch(settingNotifierProvider);
    return AudioPlayerState.stopped;
  }
  Future<bool> _init() async {
    final res = await _audioPlayer.openPlayer();
    if (res == null) {
      return false;
    }
    _configureAudioSession();
    return true;
  }
  Future _configureAudioSession() async {
    final session = await AudioSession.instance;
    await session.configure(const AudioSessionConfiguration());
  }
  void play(String path) async {
    final ByteData data = await rootBundle.load(path);
    playFile(data: data);
  }
  void playFile({
    required ByteData data,
    String? fileName,
  }) async {
    try {
      if (_setting.globalSoundEnabled == false) {
        return;
      }
      await _audioPlayer.stopPlayer();
      while (_audioPlayer.isPlaying) {
        await Future.delayed(const Duration(milliseconds: 50));
      }
      if (!_audioPlayer.isOpen()) {
        await _audioPlayer.openPlayer();
      }
      await _audioPlayer.startPlayer(
        fromDataBuffer: data.buffer.asUint8List(),
        whenFinished: () {
          state = AudioPlayerState.stopped;
        },
      );
      state = AudioPlayerState.playing;
    } catch (e) {
      debugPrint('Error playing audio: $e');
      if (fileName != null) {
        try {
          Directory tempDir = await getTemporaryDirectory();
          File fileToDelete = File('${tempDir.path}/$fileName');
          if (await fileToDelete.exists()) {
            await fileToDelete.delete();
            debugPrint('File deleted successfully: $fileName');
          } else {
            debugPrint('File not found: $fileName');
          }
        } catch (e) {
          debugPrint('Error deleting file: $e');
        }
      }
    }
  }
  void stop() async {
    await _audioPlayer.stopPlayer();
    state = AudioPlayerState.stopped;
  }
}
---
Path: /lib/services/currency_service.dart

import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:twins/services/storage/currency_storage.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
part 'currency_service.g.dart';
@riverpod
class CurrencyService extends _$CurrencyService {
  final CurrencyStorage _storage = CurrencyStorage(const FlutterSecureStorage());
  @override
  int build() {
    getCurrency();
    return 0;
  }
  void getCurrency() async {
    state = await _storage.read() ?? 0;
  }
  void setCurrency(int currency) {
    _storage.save(currency);
    state = currency;
  }
  void addCurrency(int currency) {
    _storage.add(currency);
    state = state + currency;
  }
  void subCurrency(int currency) {
    _storage.sub(currency);
    state = state - currency;
  }
  bool canAfford(int cost) {
    return state >= cost;
  }
}
---
Path: /lib/services/iap_service.dart

import 'dart:io' show Platform;
import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';
import 'package:twins/utilities/logger.dart';
import 'package:logger/logger.dart';
import 'package:purchases_flutter/purchases_flutter.dart';
import 'package:twins/utilities/env.dart';
const _GENIUS_PRO_PRODUCT_ID = 'subscription_monthly_1';
class IapService extends ChangeNotifier {
  StoreProduct? _pro;
  StoreProduct? get pro => _pro;
  CustomerInfo? _info;
  CustomerInfo? get info => _info;
  bool get isPro => _info?.entitlements.active.containsKey('pro') ?? false;
  final _logger = Logger(
    printer: createSimplePrefixPrinter(
      PrettyPrinter(methodCount: 3),
      prefix: '[IAP]',
    ),
  );
  IapService() {
    _initialize();
  }
  void _initialize() async {
    await Purchases.setLogLevel((!kReleaseMode) ? LogLevel.debug : LogLevel.error);
    PurchasesConfiguration configuration;
    if (Platform.isAndroid) {
      configuration = PurchasesConfiguration(Env.revenueCatAndroidApiKey);
    } else if (Platform.isIOS) {
      configuration = PurchasesConfiguration(Env.revenueCatIosApiKey);
    } else {
      throw Exception('Unsupported platform');
    }
    await Purchases.configure(configuration);
    _info = await Purchases.getCustomerInfo();
    final products = await Purchases.getProducts(
      [_GENIUS_PRO_PRODUCT_ID],
      type: PurchaseType.subs,
    );
    if (products.isNotEmpty) {
      _pro = products.first;
    }
    notifyListeners();
  }
  Future<bool> purchasePro() async {
    try {
      _info = await Purchases.purchaseProduct(
        _GENIUS_PRO_PRODUCT_ID,
        type: PurchaseType.inapp,
      );
      notifyListeners();
      return true;
    } 
    on PlatformException catch (e) {
      if (PurchasesErrorHelper.getErrorCode(e) == PurchasesErrorCode.purchaseCancelledError) {
      } else {
        _logger.log(Level.error, "Error: ${PurchasesErrorHelper.getErrorCode(e)}: ${e.toString()}");
      }
    } catch (e) {
      _logger.log(Level.error, e.toString());
    }
    return false;
  }
  Future<bool> restorePro() async {
    try {
      _info = await Purchases.restorePurchases();
      notifyListeners();
      if (!isPro) {
        return false;
      }
      return true;
    } on PlatformException catch (e) {
      if (PurchasesErrorHelper.getErrorCode(e) == PurchasesErrorCode.purchaseCancelledError) {
        _logger.log(Level.error, 'Restore canceled: ${e.toString()}');
      } else {
        _logger.log(Level.error, "Error: ${PurchasesErrorHelper.getErrorCode(e)}: ${e.toString()}");
      }
    } catch (e) {
      _logger.log(Level.error, e.toString());
    }
    return false;
  }
}
---
Path: /lib/services/like_genius_service.dart

import 'package:twins/providers/genius_result_provider.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:shared_preferences/shared_preferences.dart';
part 'like_genius_service.g.dart';
@riverpod
class LikeGeniusService extends _$LikeGeniusService {
  late SharedPreferences _prefs;
  late int _count;
  late bool _hasFilledSurvey;
  @override
  bool? build() {
    final SharedPreferences? tmpPrefs = ref.watch(prefsProvider).maybeMap(
        orElse: () => null,
        data: (value) {
          return value.value;
        });
    if (tmpPrefs == null) return null;
    _prefs = tmpPrefs;
    _count = _prefs.getInt('practice_count') ?? 0;
    _hasFilledSurvey = _prefs.getBool('has_filled_survey') ?? false;
    return getLikeGenius() && !_hasFilledSurvey;
  }
  bool getLikeGenius() {
    return _prefs.getBool('like_genius') ?? false;
  }
  void setLikeGenius(bool value) {
    _prefs.setBool('like_genius', value);
    state = value && !_hasFilledSurvey;
  }
  void finishedPractice() {
    _count++;
    _prefs.setInt('practice_count', _count);
    if (_count >= 6 && state == false) {
      setLikeGenius(true);
    }
  }
  void reset() {
    _prefs.remove('practice_count');
    _prefs.remove('like_genius');
    _prefs.remove('has_filled_survey');
    _hasFilledSurvey = false;
    _count = 0;
    state = false;
  }
  void saveFilled() {
    _hasFilledSurvey = true;
    _prefs.setBool('has_filled_survey', true);
    state = false;
  }
}
---
Path: /lib/services/message_capability_service.dart

import 'package:flutter/foundation.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:twins/hooks/use_logger.dart';
import 'package:twins/models/user_capability.dart';
import 'package:twins/services/iap_service.dart';
import 'package:twins/services/storage/message_count_secure_storage.dart';
extension on DateTime {
  DateTime clearTimeAfterDuration(Duration duration) {
    if (duration >= const Duration(days: 1)) {
      return DateTime(year, month, day);
    } else if (duration >= const Duration(hours: 1)) {
      return DateTime(year, month, day, hour);
    } else if (duration >= const Duration(minutes: 1)) {
      return DateTime(year, month, day, hour, minute);
    } else if (duration >= const Duration(milliseconds: 1)) {
      return DateTime(year, month, day, hour, minute, second, millisecond);
    }
    return this;
  }
}
class MessageCapabilityService extends ChangeNotifier {
  static const int _messageLimit = 30;
  UserCapabilityState _state = const UserCapabilityState.initial();
  int _messageCount = 0;
  static const Duration _messageLimitDuration = Duration(days: 1);
  static const String _capabilityMessageDateKey = 'capability_message_date';
  static const String _activationCodeKey = 'activation_code';
  DateTime? _capabilityMessageDate;
  final IapService _iapService;
  final MessageCountSecureStorage _messageCountSecureStorage;
  final FlutterSecureStorage _secureStorage;
  MessageCapabilityService({
    required IapService iapService,
    required MessageCountSecureStorage messageCountSecureStorage,
    required FlutterSecureStorage secureStorage,
  })  : _iapService = iapService,
        _messageCountSecureStorage = messageCountSecureStorage,
        _secureStorage = secureStorage {
    _initialize();
  }
  UserCapabilityState get state => _state;
  final _logger = useLogger();
  Future<void> _initialize() async {
    await _loadCapabilityMessageDate();
    await _loadMessageCount();
    await _updateState();
  }
  bool checkResetMessageCount() {
    DateTime currentDate = DateTime.now().clearTimeAfterDuration(_messageLimitDuration);
    _logger.d('Current date: $currentDate');
    _logger.d(
        'Capability message date: ${_capabilityMessageDate!.clearTimeAfterDuration(_messageLimitDuration)}');
    final difference = currentDate
        .difference(_capabilityMessageDate!.clearTimeAfterDuration(_messageLimitDuration));
    if (difference >= _messageLimitDuration) {
      _logger.d('Need to reset message count and date');
      return true;
    }
    return false;
  }
  Future<void> _loadCapabilityMessageDate() async {
    final capabilityMessageDate = await _secureStorage.read(key: _capabilityMessageDateKey);
    if (capabilityMessageDate != null) {
      _capabilityMessageDate = DateTime.parse(capabilityMessageDate);
      return;
    }
    var date = DateTime.now().clearTimeAfterDuration(_messageLimitDuration);
    await _storeCapabilityMessageDate(date);
  }
  Future<void> _storeCapabilityMessageDate(DateTime date) async {
    final dateString = date.toIso8601String();
    await _secureStorage.write(key: _capabilityMessageDateKey, value: dateString);
    _capabilityMessageDate = date;
  }
  Future<void> _loadMessageCount() async {
    final count = await _messageCountSecureStorage.read();
    _messageCount = count ?? 0;
  }
  Future<void> incrementMessageCount() async {
    _messageCount++;
    _logger.d('Message count: $_messageCount');
    await _messageCountSecureStorage.increment();
    _updateState();
  }
  Future<void> _updateState() async {
    if (await _canSend()) {
      _state = const UserCapabilityState.can();
    } else {
      _state = const UserCapabilityState.limitReached();
    }
    notifyListeners();
  }
  Future<void> _resetMessageCount() async {
    var date = DateTime.now().clearTimeAfterDuration(_messageLimitDuration);
    _logger.d('New capability message date: $date');
    await _storeCapabilityMessageDate(date);
    _capabilityMessageDate = date;
    _messageCount = 0;
    await _messageCountSecureStorage.clear();
  }
  Future<bool> _isActivatedByCode() async {
    final code = await _secureStorage.read(key: _activationCodeKey);
    return code != null;
  }
  Future<bool> _canSend() async {
    if (_iapService.isPro) {
      return true;
    }
    if (await _isActivatedByCode()) {
      return true;
    }
    if (checkResetMessageCount()) {
      await _resetMessageCount();
    }
    return _messageCount < _messageLimit;
  }
  Future<bool> get canSendMessage async => await _canSend();
  Future<void> activateByCode(String code) async {
    await _secureStorage.write(key: _activationCodeKey, value: code);
  }
  Future<void> reset() async {
    await _resetMessageCount();
    await _updateState();
    await _secureStorage.delete(key: _activationCodeKey);
  }
}
---
Path: /lib/services/notifications_panel_service.dart

import 'package:flutter/material.dart';
import 'package:twins/models/notification_panel_model.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
part 'notifications_panel_service.g.dart';
@riverpod
class NotificationsPanelService extends _$NotificationsPanelService {
  @override
  List<NotificationPanelData> build() {
    return [];
  }
  void addNotificationPanelData(NotificationPanelType notificationType, Widget child) {
    String generatedId = UniqueKey().toString();
    NotificationPanelData notificationPanelData = NotificationPanelData(
      id: generatedId,
      notificationType: notificationType,
      child: child,
    );
    state = [...state, notificationPanelData];
  }
  void removeNotificationPanelData(String id) {
    state = state.where((element) {
      return element.id != id;
    }).toList();
  }
}
---
Path: /lib/services/speech_to_text_service.dart

import 'dart:async';
import 'package:twins/models/speech_to_text_model.dart';
import 'package:logger/logger.dart';
import 'package:twins/utilities/analytics.dart';
import 'package:twins/utilities/logger.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:rxdart/subjects.dart';
import 'package:speech_to_text/speech_to_text.dart';
import 'package:collection/collection.dart';
part 'speech_to_text_service.g.dart';
@riverpod
class SpeechToTextService extends _$SpeechToTextService {
  @override
  SpeechToTextState build() {
    _initialize();
    return const SpeechToTextState(
      hasAccess: false,
      status: SpeechToTextStatus.stopped,
      error: null,
    );
  }
  final Logger _logger = Logger(
    printer: createSimplePrefixPrinter(
      PrettyPrinter(methodCount: 3),
      prefix: '[Speech-to-Text]',
    ),
  );
  final SpeechToText _speechToText = SpeechToText();
  var _availableLocales = <LocaleName>[];
  var _isInitialized = false;
  LocaleName? _locale;
  bool get _isReady => _isInitialized && _locale != null;
  void _initialize() async {
    try {
      _logger.i('Speech-to-text trying to initialize');
      final success = await _speechToText.initialize(
        onStatus: (status) {
          _logger.i('Speech-to-text status changed to $status.');
          SpeechToTextStatus currentStatus;
          if (status == SpeechToText.listeningStatus) {
            currentStatus = SpeechToTextStatus.listening;
          } else if (status == SpeechToText.notListeningStatus) {
            currentStatus = SpeechToTextStatus.stopped;
          } else {
            currentStatus = SpeechToTextStatus.failure;
          }
          state = state.copyWith(status: currentStatus);
        },
        onError: (error) {
          state = state.copyWith(status: SpeechToTextStatus.failure, error: error.errorMsg);
        },
      );
      if (success) {
        _logger.i('Speech-to-text initialized successfully.');
        _isInitialized = true;
        _availableLocales = await _speechToText.locales();
        setLanguage('en');
      } else {
        _logger.i('Speech-to-text failed to initialize.');
      }
    } catch (error) {
      _logger.e('Speech-to-text failed to initialize and produced an error.', error);
    }
  }
  bool setLanguage(String language) {
    if (_availableLocales.isEmpty) {
      state = state.copyWith(error: 'Speech-to-text locales have not loaded yet.');
      return false;
    }
    final locale =
        _availableLocales.firstWhereOrNull((locale) => locale.localeId.startsWith(language));
    if (locale != null) {
      _logger.i(
        'Now using speech-to-text locale ${locale.name} (${locale.localeId}), '
        'mapped from language "$language".',
      );
      _locale = locale;
      state = state.copyWith(hasAccess: true, error: null, status: SpeechToTextStatus.stopped);
    } else {
      _logger.w(
        'Failed to find a speech-to-text locale for language "$language". '
        'Available locales are: ${_availableLocales.map((locale) => "${locale.name} (${locale.localeId})").join(', ')}.',
      );
      state = state.copyWith(
          hasAccess: true,
          error: 'Failed to find a speech-to-text locale for language "$language". ');
      _locale = null;
    }
    return _locale != null;
  }
  Stream<String> listen() {
    if (!_isReady) {
      throw StateError('Speech-to-text is not ready yet.');
    }
    Analytics.trackSpeechToText();
    final subject = PublishSubject<String>();
    _speechToText.listen(
      localeId: _locale?.localeId,
      listenMode: ListenMode.search,
      cancelOnError: true,
      partialResults: true,
      onResult: (result) {
        _logger.i('Speech-to-text result: ${result.recognizedWords}');
        _logger.i('Speech-to-text isFinal: ${result.finalResult}');
        subject.add(result.recognizedWords);
        if (result.finalResult) {
          subject.close();
        }
      },
    );
    return subject.stream;
  }
  void stop() {
    _speechToText.stop();
  }
  void cancel() {
    _speechToText.cancel();
  }
}
---
Path: /lib/services/store_messages_service.dart

import 'package:twins/models/api/chat_request.dart';
import 'package:twins/utilities/shared_preferences_utils.dart';
import 'dart:convert';
class StorageMessagesService {
  static Map<String, List<ChatExchange>> cachedChatHistory = {};
  static const int maxMessages = 100;
  static Future<void> saveChatHistory({required String conversationKey}) async {
    List<ChatExchange> tmp = cachedChatHistory[conversationKey] ?? [];
    if (cachedChatHistory.length > maxMessages) {
      tmp = tmp.sublist(tmp.length - maxMessages);
    }
    final List<String> stringChatHistory =
        tmp.map((chatExchange) => jsonEncode(chatExchange.toJson())).toList();
    await SharedPreferencesUtil.setStringList('chat_history_$conversationKey', stringChatHistory);
  }
  static Future<List<ChatExchange>> getChatHistory({required String conversationKey}) async {
    final List<String> stringChatHistory =
        SharedPreferencesUtil.getStringList('chat_history_$conversationKey');
    cachedChatHistory[conversationKey] = stringChatHistory
        .map((stringChatExchange) => ChatExchange.fromJson(jsonDecode(stringChatExchange)))
        .toList();
    return cachedChatHistory[conversationKey] ?? [];
  }
  static Future<void> clearChatHistory({required String conversationKey}) async {
    await SharedPreferencesUtil.remove('chat_history_$conversationKey');
    cachedChatHistory[conversationKey] = [];
  }
  static Future<void> addMessage(ChatExchange message, {required String conversationKey}) async {
    await addMessages([message], conversationKey: conversationKey);
  }
  static Future<void> addMessages(List<ChatExchange> messages,
      {required String conversationKey}) async {
    final tmp = cachedChatHistory[conversationKey] ?? [];
    tmp.addAll(messages);
    cachedChatHistory[conversationKey] = tmp;
    await saveChatHistory(conversationKey: conversationKey);
  }
}
---
Path: /lib/services/genius_result_service.dart

import 'package:twins/models/results/exercise_result.dart';
import 'package:twins/models/results/genius_result.dart';
import 'package:twins/models/results/section_result.dart';
import 'package:twins/providers/exercise_result_repository_provider.dart';
import 'package:twins/providers/genius_result_provider.dart';
import 'package:twins/services/repositories/genius_result_repository.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'repositories/exercise_result_repository.dart';
part 'genius_result_service.g.dart';
@riverpod
class GeniusResultService extends _$GeniusResultService {
  late GeniusResultRepository _repo;
  late ExerciseResultRepository _exerciseResultRepo;
   @override
  GeniusResult? build() {
    GeniusResultRepository? tmpRepo = ref.watch(geniusResultRepositoryProvider);
    ExerciseResultRepository? tmpExerciseRepo = ref.watch(exerciseResultRepositoryProvider);
    if (tmpRepo == null || tmpExerciseRepo == null) return null;
    _repo = tmpRepo;
    _exerciseResultRepo = tmpExerciseRepo;
    return _repo.getResults();
  }
  Future<void> submitExerciseResult(ExerciseResult result) async {
    await _exerciseResultRepo.submitResult(result);
  }
  void setPracticeResult({
    String? level,
    String? module,
    String? lesson,
    String? practice,
    SectionResult? result,
  }) {
    state = _repo.setPracticeResult(
      level: level,
      module: module,
      lesson: lesson,
      practice: practice,
      result: result,
    );
  }
  SectionResult? getPracticeResult({
    String? level,
    String? module,
    String? lesson,
    String? practice,
  }) {
    return _repo.getPracticeResult(
      level: level,
      module: module,
      lesson: lesson,
      practice: practice,
    );
  }
  void reset() {
    state = _repo.reset();
    ref.invalidateSelf();
  }
}
---
Path: /lib/services/api/genius_api.dart

import 'package:dio/dio.dart';
import 'package:flutter/material.dart';
import 'package:twins/models/api/chat_request.dart';
import 'package:twins/models/results/exercise_result.dart';
const _modulesApiEndpoint = '/modules/';
const _exerciseResultEndpoint = '/space-repetition/exercise-result';
class GeniusApi {
  final Dio _dio;
  GeniusApi(this._dio);
  Future<Response<dynamic>> fetchModulesApiRequest(String? userLevel) async {
    try {
      final options = userLevel != null ? Options(headers: {'user-level': userLevel}) : null;
      final res = await _dio.get(_modulesApiEndpoint, options: options);
      return res;
    } catch (e) {
      rethrow;
    }
  }
  Future<Response<dynamic>> postChat(ChatRequestData data) async {
    return await _dio.post('/chat', data: data);
  }
  Future<Response<dynamic>> submitExerciseResult(ExerciseResult result) async {
    try {
      final data = result.toSubmitJson();
      final response = await _dio.post(
        _exerciseResultEndpoint,
        data: data,
      );
      debugPrint("RESPONSE : ${response.data}");
      return response;
    } catch (e) {
      debugPrint("Error submitting exercise result: $e");
      rethrow;
    }
  }
}
---
Path: /lib/services/repositories/exercise_result_repository.dart

import 'package:twins/models/results/exercise_result.dart';
import 'genius_repository.dart';
class ExerciseResultRepository {
  final GeniusRepository _geniusRepository;
  ExerciseResultRepository(
    this._geniusRepository,
  );
  Future<void> submitResult(ExerciseResult result) async {
    await _geniusRepository.submitExerciseResult(result);
  }
}
---
Path: /lib/services/repositories/genius_repository.dart

import 'package:dio/dio.dart';
import 'package:twins/models/api/chat_request.dart';
import 'package:twins/models/api/module_request.dart';
import 'package:twins/models/results/exercise_result.dart';
import 'package:twins/services/api/genius_api.dart';
import 'package:logger/logger.dart';
class GeniusRepository {
  final GeniusApi _geniusApi;
  final _logger = Logger();
  GeniusRepository(this._geniusApi);
  Future<List<GeniusModule>> fetchModules(String? userLevel) async {
    if (userLevel == null) {
      return [];
    }
    try {
      final response = await _geniusApi.fetchModulesApiRequest(userLevel);
      List jsonList = response.data;
      _logger.d("Response: $jsonList");
      List<GeniusModule> modules = jsonList.map((item) => GeniusModule.fromJson(item)).toList();
      _logger.e("Modules: $modules");
      return modules;
    } on DioException catch (e) {
      final errorMessage = StringBuffer("Error: ${e.message}\n");
      _logger.e(errorMessage.toString());
      rethrow;
    }
  }
  Future<ChatResponse> postChat(List<ChatExchange> dialogue, String id) async {
    ChatRequestData data = ChatRequestData(characterInfoId: id, dialogue: dialogue);
    final res = await _geniusApi.postChat(data);
    return ChatResponse.fromJson(res.data);
  }
  Future<void> submitExerciseResult(ExerciseResult result) async {
    try {
      final response = await _geniusApi.submitExerciseResult(result);
      if (response.statusCode == 201) {
        _logger.d('${response.data['message']}');
      } else {
        _logger.e('Failed to record exercise result: ${response.data['message']}');
      }
    } on DioException catch (e) {
      final errorMessage = StringBuffer("Error: ${e.message}\n");
      _logger.e(errorMessage.toString());
      rethrow;
    }
  }
}
---
Path: /lib/services/repositories/genius_result_repository.dart

import 'dart:convert';
import 'package:twins/models/results/genius_result.dart';
import 'package:twins/models/results/lesson_result.dart';
import 'package:twins/models/results/level_result.dart';
import 'package:twins/models/results/module_result.dart';
import 'package:twins/models/results/section_result.dart';
import 'package:logger/logger.dart';
import 'package:shared_preferences/shared_preferences.dart';
class GeniusResultRepository {
  static const String resultsKey = "genius_results";
  final _logger = Logger();
  final SharedPreferences prefs;
  GeniusResult? _cachedResults;
  GeniusResultRepository(this.prefs);
  GeniusResult getResults() {
    GeniusResult? result;
    if (_cachedResults != null) {
      _logger.i("Using cached results");
      return _cachedResults!;
    }
    final resultsString = prefs.getString(resultsKey);
    if (resultsString == null) {
      result = const GeniusResult(levels: {});
    } else {
      try {
        final Map<String, Object?> json = jsonDecode(resultsString);
        result = GeniusResult.fromJson(json);
        return result;
      } catch (e) {
        result = const GeniusResult(levels: {});
      }
    }
    _cachedResults = result;
    return result;
  }
  double? getLessonScore(LessonResult lesson) {
    if (lesson.sections.values.isEmpty) {
      return null;
    }
    return lesson.sections.values.map((value) => value.score).reduce((a, b) => a + b) /
        lesson.sections.values.length;
  }
  LessonResult updateLessonScore(LessonResult lesson) {
    if (lesson.sections.values.isEmpty) {
      return lesson;
    }
    return lesson.copyWith(
      score: getLessonScore(lesson),
    );
  }
  double? getModuleScore(ModuleResult module) {
    if (module.lessons.values.isEmpty) {
      return null;
    }
    return module.lessons.values
            .map((value) => getLessonScore(value))
            .reduce((a, b) => (a ?? 0) + (b ?? 0))! /
        module.lessons.values.length;
  }
  ModuleResult updateModuleScore(ModuleResult module) {
    if (module.lessons.values.isEmpty) {
      return module;
    }
    return module.copyWith(
      score: getModuleScore(module),
    );
  }
  double? getLevelScore(LevelResult level) {
    if (level.modules.values.isEmpty) {
      return null;
    }
    return level.modules.values
            .map((value) => getModuleScore(value))
            .reduce((a, b) => (a ?? 0) + (b ?? 0))! /
        level.modules.values.length;
  }
  LevelResult updateLevelScore(LevelResult level) {
    if (level.modules.values.isEmpty) {
      return level;
    }
    return level.copyWith(
      score: getLevelScore(level),
    );
  }
  double? getScore(GeniusResult result) {
    if (result.levels.values.isEmpty) {
      return null;
    }
    return result.levels.values
            .map((value) => getLevelScore(value))
            .reduce((a, b) => (a ?? 0) + (b ?? 0))! /
        result.levels.values.length;
  }
  GeniusResult setPracticeResult({
    String? level,
    String? module,
    String? lesson,
    String? practice,
    SectionResult? result,
  }) {
    if (level == null || module == null || lesson == null || practice == null || result == null) {
      return getResults();
    }
    GeniusResult currentResults = getResults();
    LessonResult lessonResult = currentResults.levels[level]?.modules[module]?.lessons[lesson] ??
        const LessonResult(
          sections: {},
          score: null,
        );
    lessonResult = lessonResult.copyWith(
      sections: {
        ...lessonResult.sections,
        practice: result,
      },
    );
    lessonResult = updateLessonScore(lessonResult);
    ModuleResult moduleResult = currentResults.levels[level]?.modules[module] ??
        const ModuleResult(
          lessons: {},
          score: null,
        );
    moduleResult = moduleResult.copyWith(
      lessons: {
        ...moduleResult.lessons,
        lesson: lessonResult,
      },
    );
    moduleResult = updateModuleScore(moduleResult);
    LevelResult levelResult = currentResults.levels[level] ??
        const LevelResult(
          modules: {},
          score: null,
        );
    levelResult = levelResult.copyWith(
      modules: {
        ...levelResult.modules,
        module: moduleResult,
      },
    );
    levelResult = updateLevelScore(levelResult);
    currentResults = currentResults.copyWith(
      levels: {
        ...currentResults.levels,
        level: levelResult,
      },
    );
    return save(currentResults);
  }
  GeniusResult save(GeniusResult result) {
    prefs.setString(resultsKey, jsonEncode(result.toJson()));
    return result;
  }
  GeniusResult reset() {
    return save(const GeniusResult(levels: {}));
  }
  SectionResult? getPracticeResult({
    String? level,
    String? module,
    String? lesson,
    String? practice,
  }) {
    if (level == null || module == null || lesson == null || practice == null) {
      return null;
    }
    final GeniusResult currentResults = getResults();
    if (currentResults.levels[level] == null) {
      return null;
    }
    if (currentResults.levels[level]?.modules[module] == null) {
      return null;
    }
    if (currentResults.levels[level]?.modules[module]?.lessons[lesson] == null) {
      return null;
    }
    return currentResults.levels[level]?.modules[module]?.lessons[lesson]?.sections[practice];
  }
}
---
Path: /lib/services/storage/currency_storage.dart

import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:twins/services/storage/storage_int.dart';
class CurrencyStorage extends StorageInt {
  CurrencyStorage(FlutterSecureStorage storage) : super(storage);
  @override
  String get key => 'currency';
}
---
Path: /lib/services/storage/filled_survey_storage.dart

import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:twins/services/storage/storage_bool.dart';
class FilledSurveyStorage extends StorageBool {
  FilledSurveyStorage(FlutterSecureStorage storage) : super(storage);
  @override
  String get key => 'filled_survey';
}
---
Path: /lib/services/storage/message_count_secure_storage.dart

import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:twins/services/storage/storage_int.dart';
class MessageCountSecureStorage extends StorageInt {
  MessageCountSecureStorage(FlutterSecureStorage storage) : super(storage);
  @override
  String get key => 'message_count';
}
---
Path: /lib/services/storage/storage_bool.dart

import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:twins/services/storage/storage_interface.dart';
abstract class StorageBool implements StorageInterface<bool> {
  final FlutterSecureStorage _storage;
  StorageBool(this._storage);
  bool? _cachedValue;
  bool? _defaultValue;
  @override
  Future<void> save(bool value) {
    _cachedValue = value;
    return _storage.write(key: key, value: value.toString());
  }
  @override
  Future<bool?> read() async {
    if (_cachedValue != null) {
      return _cachedValue;
    }
    final valueString = await _storage.read(key: key);
    if (valueString == null) {
      return _defaultValue;
    }
    return _cachedValue = bool.tryParse(valueString);
  }
  @override
  Future<void> clear() {
    _cachedValue = null;
    return _storage.delete(key: key);
  }
}
---
Path: /lib/services/storage/storage_double.dart

import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:twins/services/storage/storage_interface.dart';
abstract class StorageDouble implements StorageInterface<double> {
  final FlutterSecureStorage _storage;
  StorageDouble(this._storage);
  double? _cachedValue;
  double? _defaultValue;
  @override
  Future<void> save(double value) {
    _cachedValue = value;
    return _storage.write(key: key, value: value.toString());
  }
  @override
  Future<double?> read() async {
    if (_cachedValue != null) {
      return _cachedValue;
    }
    final valueString = await _storage.read(key: key);
    if (valueString == null) {
      return _defaultValue;
    }
    return _cachedValue = double.tryParse(valueString);
  }
  @override
  Future<void> clear() {
    _cachedValue = null;
    return _storage.delete(key: key);
  }
  Future<void> add(double added) async {
    if (_cachedValue != null) {
      return save(_cachedValue! + added);
    }
    final tmpValue = await read();
    if (tmpValue != null) {
      return save(tmpValue + added);
    } else if (_defaultValue != null) {
      return save(_defaultValue! + added);
    }
    return save(added);
  }
  Future<void> sub(double subbed) async {
    return add(-subbed);
  }
  Future<void> increment() async {
    return add(1);
  }
  Future<void> decrement() async {
    return sub(1);
  }
}
---
Path: /lib/services/storage/storage_int.dart

import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:twins/services/storage/storage_interface.dart';
abstract class StorageInt implements StorageInterface<int> {
  final FlutterSecureStorage _storage;
  StorageInt(this._storage);
  int? _cachedValue;
  int? _defaultValue;
  @override
  Future<void> save(int value) {
    _cachedValue = value;
    return _storage.write(key: key, value: value.toString());
  }
  @override
  Future<int?> read() async {
    if (_cachedValue != null) {
      return _cachedValue;
    }
    final valueString = await _storage.read(key: key);
    if (valueString == null) {
      return _defaultValue;
    }
    return _cachedValue = int.tryParse(valueString);
  }
  @override
  Future<void> clear() {
    _cachedValue = null;
    return _storage.delete(key: key);
  }
  Future<void> add(int added) async {
    if (_cachedValue != null) {
      return save(_cachedValue! + added);
    }
    final tmpValue = await read();
    if (tmpValue != null) {
      return save(tmpValue + added);
    } else if (_defaultValue != null) {
      return save(_defaultValue! + added);
    }
    return save(added);
  }
  Future<void> sub(int subbed) async {
    return add(-subbed);
  }
  Future<void> increment() async {
    return add(1);
  }
  Future<void> decrement() async {
    return sub(1);
  }
}
---
Path: /lib/services/storage/storage_interface.dart

abstract class StorageInterface<T> {
  String get key;
  Future<T?> read();
  Future<void> save(T credentials);
  Future<void> clear();
}
---

